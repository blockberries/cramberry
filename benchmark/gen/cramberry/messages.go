// Code generated by cramberry. DO NOT EDIT.
// Source: /Volumes/Tendermint/stealth/cramberry/benchmark/schemas/messages.cramberry

package cramgen

import (
	"github.com/blockberries/cramberry/pkg/cramberry"
)

// Status represents entity status.
type Status int32

const (
	StatusUnknown   Status = 0
	StatusPending   Status = 1
	StatusActive    Status = 2
	StatusSuspended Status = 3
	StatusDeleted   Status = 4
)

// String returns the string representation of the enum value.
func (e Status) String() string {
	switch e {
	case StatusUnknown:
		return "UNKNOWN"
	case StatusPending:
		return "PENDING"
	case StatusActive:
		return "ACTIVE"
	case StatusSuspended:
		return "SUSPENDED"
	case StatusDeleted:
		return "DELETED"
	default:
		return "UNKNOWN"
	}
}

// IsValid returns true if the value is a valid enum value.
func (e Status) IsValid() bool {
	switch e {
	case StatusUnknown:
		return true
	case StatusPending:
		return true
	case StatusActive:
		return true
	case StatusSuspended:
		return true
	case StatusDeleted:
		return true
	default:
		return false
	}
}

// encodeTo encodes the enum value directly to the writer.
func (e Status) encodeTo(w *cramberry.Writer) {
	w.WriteInt32(int32(e))
}

// decodeFrom decodes the enum value from the reader.
func (e *Status) decodeFrom(r *cramberry.Reader) {
	*e = Status(r.ReadInt32())
}

// Priority levels.
type Priority int32

const (
	PriorityLow      Priority = 0
	PriorityMedium   Priority = 1
	PriorityHigh     Priority = 2
	PriorityCritical Priority = 3
)

// String returns the string representation of the enum value.
func (e Priority) String() string {
	switch e {
	case PriorityLow:
		return "LOW"
	case PriorityMedium:
		return "MEDIUM"
	case PriorityHigh:
		return "HIGH"
	case PriorityCritical:
		return "CRITICAL"
	default:
		return "UNKNOWN"
	}
}

// IsValid returns true if the value is a valid enum value.
func (e Priority) IsValid() bool {
	switch e {
	case PriorityLow:
		return true
	case PriorityMedium:
		return true
	case PriorityHigh:
		return true
	case PriorityCritical:
		return true
	default:
		return false
	}
}

// encodeTo encodes the enum value directly to the writer.
func (e Priority) encodeTo(w *cramberry.Writer) {
	w.WriteInt32(int32(e))
}

// decodeFrom decodes the enum value from the reader.
func (e *Priority) decodeFrom(r *cramberry.Reader) {
	*e = Priority(r.ReadInt32())
}

// EventType for event messages.
type EventType int32

const (
	EventTypeCreated EventType = 0
	EventTypeUpdated EventType = 1
	EventTypeDeleted EventType = 2
	EventTypeViewed  EventType = 3
	EventTypeShared  EventType = 4
)

// String returns the string representation of the enum value.
func (e EventType) String() string {
	switch e {
	case EventTypeCreated:
		return "CREATED"
	case EventTypeUpdated:
		return "UPDATED"
	case EventTypeDeleted:
		return "DELETED"
	case EventTypeViewed:
		return "VIEWED"
	case EventTypeShared:
		return "SHARED"
	default:
		return "UNKNOWN"
	}
}

// IsValid returns true if the value is a valid enum value.
func (e EventType) IsValid() bool {
	switch e {
	case EventTypeCreated:
		return true
	case EventTypeUpdated:
		return true
	case EventTypeDeleted:
		return true
	case EventTypeViewed:
		return true
	case EventTypeShared:
		return true
	default:
		return false
	}
}

// encodeTo encodes the enum value directly to the writer.
func (e EventType) encodeTo(w *cramberry.Writer) {
	w.WriteInt32(int32(e))
}

// decodeFrom decodes the enum value from the reader.
func (e *EventType) decodeFrom(r *cramberry.Reader) {
	*e = EventType(r.ReadInt32())
}

// Point represents a 3D point.
type Point struct {
	X float64 `cramberry:"1" json:"x"`
	Y float64 `cramberry:"2" json:"y"`
	Z float64 `cramberry:"3" json:"z"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Point) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Point) encodeTo(w *cramberry.Writer) {
	if m.X != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Fixed64)
		w.WriteFloat64(m.X)
	}
	if m.Y != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Fixed64)
		w.WriteFloat64(m.Y)
	}
	if m.Z != 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2Fixed64)
		w.WriteFloat64(m.Z)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Point) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Point) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.X = r.ReadFloat64()
		case 2:
			m.Y = r.ReadFloat64()
		case 3:
			m.Z = r.ReadFloat64()
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Timestamp represents a point in time.
type Timestamp struct {
	Seconds int64 `cramberry:"1" json:"seconds"`
	Nanos   int32 `cramberry:"2" json:"nanos"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Timestamp) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Timestamp) encodeTo(w *cramberry.Writer) {
	if m.Seconds != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Seconds)
	}
	if m.Nanos != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Nanos)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Timestamp) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Timestamp) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Seconds = r.ReadInt64()
		case 2:
			m.Nanos = r.ReadInt32()
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Duration represents a time duration.
type Duration struct {
	Seconds int64 `cramberry:"1" json:"seconds"`
	Nanos   int32 `cramberry:"2" json:"nanos"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Duration) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Duration) encodeTo(w *cramberry.Writer) {
	if m.Seconds != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Seconds)
	}
	if m.Nanos != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Nanos)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Duration) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Duration) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Seconds = r.ReadInt64()
		case 2:
			m.Nanos = r.ReadInt32()
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Metrics contains various numeric metrics.
type Metrics struct {
	Count      int64   `cramberry:"1" json:"count"`
	Sum        float64 `cramberry:"2" json:"sum"`
	Min        float64 `cramberry:"3" json:"min"`
	Max        float64 `cramberry:"4" json:"max"`
	Avg        float64 `cramberry:"5" json:"avg"`
	P50        float64 `cramberry:"6" json:"p50"`
	P95        float64 `cramberry:"7" json:"p95"`
	P99        float64 `cramberry:"8" json:"p99"`
	TotalBytes int64   `cramberry:"9" json:"total_bytes"`
	ErrorCount int64   `cramberry:"10" json:"error_count"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Metrics) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Metrics) encodeTo(w *cramberry.Writer) {
	if m.Count != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Count)
	}
	if m.Sum != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Fixed64)
		w.WriteFloat64(m.Sum)
	}
	if m.Min != 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2Fixed64)
		w.WriteFloat64(m.Min)
	}
	if m.Max != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2Fixed64)
		w.WriteFloat64(m.Max)
	}
	if m.Avg != 0 {
		w.WriteCompactTag(5, cramberry.WireTypeV2Fixed64)
		w.WriteFloat64(m.Avg)
	}
	if m.P50 != 0 {
		w.WriteCompactTag(6, cramberry.WireTypeV2Fixed64)
		w.WriteFloat64(m.P50)
	}
	if m.P95 != 0 {
		w.WriteCompactTag(7, cramberry.WireTypeV2Fixed64)
		w.WriteFloat64(m.P95)
	}
	if m.P99 != 0 {
		w.WriteCompactTag(8, cramberry.WireTypeV2Fixed64)
		w.WriteFloat64(m.P99)
	}
	if m.TotalBytes != 0 {
		w.WriteCompactTag(9, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.TotalBytes)
	}
	if m.ErrorCount != 0 {
		w.WriteCompactTag(10, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.ErrorCount)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Metrics) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Metrics) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Count = r.ReadInt64()
		case 2:
			m.Sum = r.ReadFloat64()
		case 3:
			m.Min = r.ReadFloat64()
		case 4:
			m.Max = r.ReadFloat64()
		case 5:
			m.Avg = r.ReadFloat64()
		case 6:
			m.P50 = r.ReadFloat64()
		case 7:
			m.P95 = r.ReadFloat64()
		case 8:
			m.P99 = r.ReadFloat64()
		case 9:
			m.TotalBytes = r.ReadInt64()
		case 10:
			m.ErrorCount = r.ReadInt64()
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// SmallMessage is a minimal message for baseline testing.
type SmallMessage struct {
	Id     int64  `cramberry:"1" json:"id"`
	Name   string `cramberry:"2" json:"name"`
	Active bool   `cramberry:"3" json:"active"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SmallMessage) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *SmallMessage) encodeTo(w *cramberry.Writer) {
	if m.Id != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Id)
	}
	if m.Name != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Name)
	}
	if m.Active {
		w.WriteCompactTag(3, cramberry.WireTypeV2Varint)
		w.WriteBool(m.Active)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SmallMessage) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *SmallMessage) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Id = r.ReadInt64()
		case 2:
			m.Name = r.ReadString()
		case 3:
			m.Active = r.ReadBool()
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Address represents a physical address.
type Address struct {
	Street1     string  `cramberry:"1" json:"street1"`
	Street2     *string `cramberry:"2,omitempty" json:"street2,omitempty"`
	City        string  `cramberry:"3" json:"city"`
	State       string  `cramberry:"4" json:"state"`
	PostalCode  string  `cramberry:"5" json:"postal_code"`
	Country     string  `cramberry:"6" json:"country"`
	Coordinates *Point  `cramberry:"7,omitempty" json:"coordinates,omitempty"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Address) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Address) encodeTo(w *cramberry.Writer) {
	if m.Street1 != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Street1)
	}
	if m.Street2 != nil {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.Street2)
	}
	if m.City != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.City)
	}
	if m.State != "" {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteString(m.State)
	}
	if m.PostalCode != "" {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		w.WriteString(m.PostalCode)
	}
	if m.Country != "" {
		w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Country)
	}
	if m.Coordinates != nil {
		w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
		m.Coordinates.encodeTo(w)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Address) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Address) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Street1 = r.ReadString()
		case 2:
			var tmp string
			tmp = r.ReadString()
			m.Street2 = &tmp
		case 3:
			m.City = r.ReadString()
		case 4:
			m.State = r.ReadString()
		case 5:
			m.PostalCode = r.ReadString()
		case 6:
			m.Country = r.ReadString()
		case 7:
			var tmp Point
			tmp.decodeFrom(r)
			m.Coordinates = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// ContactInfo holds contact details.
type ContactInfo struct {
	Email          string   `cramberry:"1" json:"email"`
	Phone          *string  `cramberry:"2,omitempty" json:"phone,omitempty"`
	Mobile         *string  `cramberry:"3,omitempty" json:"mobile,omitempty"`
	Fax            *string  `cramberry:"4,omitempty" json:"fax,omitempty"`
	MailingAddress *Address `cramberry:"5,omitempty" json:"mailing_address,omitempty"`
	BillingAddress *Address `cramberry:"6,omitempty" json:"billing_address,omitempty"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *ContactInfo) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *ContactInfo) encodeTo(w *cramberry.Writer) {
	if m.Email != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Email)
	}
	if m.Phone != nil {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.Phone)
	}
	if m.Mobile != nil {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.Mobile)
	}
	if m.Fax != nil {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.Fax)
	}
	if m.MailingAddress != nil {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		m.MailingAddress.encodeTo(w)
	}
	if m.BillingAddress != nil {
		w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
		m.BillingAddress.encodeTo(w)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *ContactInfo) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *ContactInfo) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Email = r.ReadString()
		case 2:
			var tmp string
			tmp = r.ReadString()
			m.Phone = &tmp
		case 3:
			var tmp string
			tmp = r.ReadString()
			m.Mobile = &tmp
		case 4:
			var tmp string
			tmp = r.ReadString()
			m.Fax = &tmp
		case 5:
			var tmp Address
			tmp.decodeFrom(r)
			m.MailingAddress = &tmp
		case 6:
			var tmp Address
			tmp.decodeFrom(r)
			m.BillingAddress = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Person represents a person entity.
type Person struct {
	Id          int64       `cramberry:"1" json:"id"`
	FirstName   string      `cramberry:"2" json:"first_name"`
	LastName    string      `cramberry:"3" json:"last_name"`
	MiddleName  *string     `cramberry:"4,omitempty" json:"middle_name,omitempty"`
	DateOfBirth *Timestamp  `cramberry:"5,omitempty" json:"date_of_birth,omitempty"`
	Contact     ContactInfo `cramberry:"6" json:"contact"`
	Status      Status      `cramberry:"7" json:"status"`
	CreatedAt   Timestamp   `cramberry:"8" json:"created_at"`
	UpdatedAt   *Timestamp  `cramberry:"9,omitempty" json:"updated_at,omitempty"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Person) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Person) encodeTo(w *cramberry.Writer) {
	if m.Id != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Id)
	}
	if m.FirstName != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.FirstName)
	}
	if m.LastName != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.LastName)
	}
	if m.MiddleName != nil {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.MiddleName)
	}
	if m.DateOfBirth != nil {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		m.DateOfBirth.encodeTo(w)
	}
	w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
	m.Contact.encodeTo(w)
	w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
	m.Status.encodeTo(w)
	w.WriteCompactTag(8, cramberry.WireTypeV2Bytes)
	m.CreatedAt.encodeTo(w)
	if m.UpdatedAt != nil {
		w.WriteCompactTag(9, cramberry.WireTypeV2Bytes)
		m.UpdatedAt.encodeTo(w)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Person) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Person) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Id = r.ReadInt64()
		case 2:
			m.FirstName = r.ReadString()
		case 3:
			m.LastName = r.ReadString()
		case 4:
			var tmp string
			tmp = r.ReadString()
			m.MiddleName = &tmp
		case 5:
			var tmp Timestamp
			tmp.decodeFrom(r)
			m.DateOfBirth = &tmp
		case 6:
			m.Contact.decodeFrom(r)
		case 7:
			m.Status.decodeFrom(r)
		case 8:
			m.CreatedAt.decodeFrom(r)
		case 9:
			var tmp Timestamp
			tmp.decodeFrom(r)
			m.UpdatedAt = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Organization represents a company or organization.
type Organization struct {
	Id           int64       `cramberry:"1" json:"id"`
	Name         string      `cramberry:"2" json:"name"`
	LegalName    string      `cramberry:"3" json:"legal_name"`
	TaxId        *string     `cramberry:"4,omitempty" json:"tax_id,omitempty"`
	Headquarters Address     `cramberry:"5" json:"headquarters"`
	Contact      ContactInfo `cramberry:"6" json:"contact"`
	Status       Status      `cramberry:"7" json:"status"`
	FoundedAt    Timestamp   `cramberry:"8" json:"founded_at"`
	CreatedAt    Timestamp   `cramberry:"9" json:"created_at"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Organization) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Organization) encodeTo(w *cramberry.Writer) {
	if m.Id != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Id)
	}
	if m.Name != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Name)
	}
	if m.LegalName != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.LegalName)
	}
	if m.TaxId != nil {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.TaxId)
	}
	w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
	m.Headquarters.encodeTo(w)
	w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
	m.Contact.encodeTo(w)
	w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
	m.Status.encodeTo(w)
	w.WriteCompactTag(8, cramberry.WireTypeV2Bytes)
	m.FoundedAt.encodeTo(w)
	w.WriteCompactTag(9, cramberry.WireTypeV2Bytes)
	m.CreatedAt.encodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Organization) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Organization) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Id = r.ReadInt64()
		case 2:
			m.Name = r.ReadString()
		case 3:
			m.LegalName = r.ReadString()
		case 4:
			var tmp string
			tmp = r.ReadString()
			m.TaxId = &tmp
		case 5:
			m.Headquarters.decodeFrom(r)
		case 6:
			m.Contact.decodeFrom(r)
		case 7:
			m.Status.decodeFrom(r)
		case 8:
			m.FoundedAt.decodeFrom(r)
		case 9:
			m.CreatedAt.decodeFrom(r)
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Tag represents a label/tag.
type Tag struct {
	Key   string  `cramberry:"1" json:"key"`
	Value string  `cramberry:"2" json:"value"`
	Color *string `cramberry:"3,omitempty" json:"color,omitempty"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Tag) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Tag) encodeTo(w *cramberry.Writer) {
	if m.Key != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Key)
	}
	if m.Value != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Value)
	}
	if m.Color != nil {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.Color)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Tag) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Tag) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Key = r.ReadString()
		case 2:
			m.Value = r.ReadString()
		case 3:
			var tmp string
			tmp = r.ReadString()
			m.Color = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Attachment represents a file attachment.
type Attachment struct {
	Id         string    `cramberry:"1" json:"id"`
	Filename   string    `cramberry:"2" json:"filename"`
	MimeType   string    `cramberry:"3" json:"mime_type"`
	SizeBytes  int64     `cramberry:"4" json:"size_bytes"`
	Checksum   []byte    `cramberry:"5" json:"checksum"`
	Url        *string   `cramberry:"6,omitempty" json:"url,omitempty"`
	UploadedAt Timestamp `cramberry:"7" json:"uploaded_at"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Attachment) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Attachment) encodeTo(w *cramberry.Writer) {
	if m.Id != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Id)
	}
	if m.Filename != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Filename)
	}
	if m.MimeType != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.MimeType)
	}
	if m.SizeBytes != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.SizeBytes)
	}
	if len(m.Checksum) > 0 {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Checksum)
	}
	if m.Url != nil {
		w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.Url)
	}
	w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
	m.UploadedAt.encodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Attachment) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Attachment) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Id = r.ReadString()
		case 2:
			m.Filename = r.ReadString()
		case 3:
			m.MimeType = r.ReadString()
		case 4:
			m.SizeBytes = r.ReadInt64()
		case 5:
			m.Checksum = r.ReadBytes()
		case 6:
			var tmp string
			tmp = r.ReadString()
			m.Url = &tmp
		case 7:
			m.UploadedAt.decodeFrom(r)
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Comment represents a user comment.
type Comment struct {
	Id        int64      `cramberry:"1" json:"id"`
	AuthorId  int64      `cramberry:"2" json:"author_id"`
	Content   string     `cramberry:"3" json:"content"`
	CreatedAt Timestamp  `cramberry:"4" json:"created_at"`
	EditedAt  *Timestamp `cramberry:"5,omitempty" json:"edited_at,omitempty"`
	Reactions []int64    `cramberry:"6" json:"reactions"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Comment) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Comment) encodeTo(w *cramberry.Writer) {
	if m.Id != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Id)
	}
	if m.AuthorId != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.AuthorId)
	}
	if m.Content != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Content)
	}
	w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
	m.CreatedAt.encodeTo(w)
	if m.EditedAt != nil {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		m.EditedAt.encodeTo(w)
	}
	if len(m.Reactions) > 0 {
		w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Reactions)))
		for _, v := range m.Reactions {
			w.WriteInt64(v)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Comment) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Comment) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Id = r.ReadInt64()
		case 2:
			m.AuthorId = r.ReadInt64()
		case 3:
			m.Content = r.ReadString()
		case 4:
			m.CreatedAt.decodeFrom(r)
		case 5:
			var tmp Timestamp
			tmp.decodeFrom(r)
			m.EditedAt = &tmp
		case 6:
			n := int(r.ReadUvarint())
			m.Reactions = make([]int64, n)
			for i := 0; i < n; i++ {
				m.Reactions[i] = r.ReadInt64()
			}
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Document with arrays and maps.
type Document struct {
	Id            int64             `cramberry:"1" json:"id"`
	Title         string            `cramberry:"2" json:"title"`
	Content       string            `cramberry:"3" json:"content"`
	AuthorId      int64             `cramberry:"4" json:"author_id"`
	Status        Status            `cramberry:"5" json:"status"`
	Priority      Priority          `cramberry:"6" json:"priority"`
	Tags          []Tag             `cramberry:"7" json:"tags"`
	Attachments   []Attachment      `cramberry:"8" json:"attachments"`
	Comments      []Comment         `cramberry:"9" json:"comments"`
	Metadata      map[string]string `cramberry:"10" json:"metadata"`
	Collaborators []int64           `cramberry:"11" json:"collaborators"`
	CreatedAt     Timestamp         `cramberry:"12" json:"created_at"`
	UpdatedAt     *Timestamp        `cramberry:"13,omitempty" json:"updated_at,omitempty"`
	PublishedAt   *Timestamp        `cramberry:"14,omitempty" json:"published_at,omitempty"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Document) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Document) encodeTo(w *cramberry.Writer) {
	if m.Id != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Id)
	}
	if m.Title != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Title)
	}
	if m.Content != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Content)
	}
	if m.AuthorId != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.AuthorId)
	}
	w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
	m.Status.encodeTo(w)
	w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
	m.Priority.encodeTo(w)
	if len(m.Tags) > 0 {
		w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Tags)))
		for _, v := range m.Tags {
			v.encodeTo(w)
		}
	}
	if len(m.Attachments) > 0 {
		w.WriteCompactTag(8, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Attachments)))
		for _, v := range m.Attachments {
			v.encodeTo(w)
		}
	}
	if len(m.Comments) > 0 {
		w.WriteCompactTag(9, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Comments)))
		for _, v := range m.Comments {
			v.encodeTo(w)
		}
	}
	if m.Metadata != nil {
		w.WriteCompactTag(10, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Metadata)))
		for k, v := range m.Metadata {
			w.WriteString(k)
			w.WriteString(v)
		}
	}
	if len(m.Collaborators) > 0 {
		w.WriteCompactTag(11, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Collaborators)))
		for _, v := range m.Collaborators {
			w.WriteInt64(v)
		}
	}
	w.WriteCompactTag(12, cramberry.WireTypeV2Bytes)
	m.CreatedAt.encodeTo(w)
	if m.UpdatedAt != nil {
		w.WriteCompactTag(13, cramberry.WireTypeV2Bytes)
		m.UpdatedAt.encodeTo(w)
	}
	if m.PublishedAt != nil {
		w.WriteCompactTag(14, cramberry.WireTypeV2Bytes)
		m.PublishedAt.encodeTo(w)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Document) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Document) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Id = r.ReadInt64()
		case 2:
			m.Title = r.ReadString()
		case 3:
			m.Content = r.ReadString()
		case 4:
			m.AuthorId = r.ReadInt64()
		case 5:
			m.Status.decodeFrom(r)
		case 6:
			m.Priority.decodeFrom(r)
		case 7:
			n := int(r.ReadUvarint())
			m.Tags = make([]Tag, n)
			for i := 0; i < n; i++ {
				m.Tags[i].decodeFrom(r)
			}
		case 8:
			n := int(r.ReadUvarint())
			m.Attachments = make([]Attachment, n)
			for i := 0; i < n; i++ {
				m.Attachments[i].decodeFrom(r)
			}
		case 9:
			n := int(r.ReadUvarint())
			m.Comments = make([]Comment, n)
			for i := 0; i < n; i++ {
				m.Comments[i].decodeFrom(r)
			}
		case 10:
			n := int(r.ReadUvarint())
			m.Metadata = make(map[string]string, n)
			for i := 0; i < n; i++ {
				var k string
				k = r.ReadString()
				var v string
				v = r.ReadString()
				m.Metadata[k] = v
			}
		case 11:
			n := int(r.ReadUvarint())
			m.Collaborators = make([]int64, n)
			for i := 0; i < n; i++ {
				m.Collaborators[i] = r.ReadInt64()
			}
		case 12:
			m.CreatedAt.decodeFrom(r)
		case 13:
			var tmp Timestamp
			tmp.decodeFrom(r)
			m.UpdatedAt = &tmp
		case 14:
			var tmp Timestamp
			tmp.decodeFrom(r)
			m.PublishedAt = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// EventSource identifies the source of an event.
type EventSource struct {
	Service  string  `cramberry:"1" json:"service"`
	Instance string  `cramberry:"2" json:"instance"`
	Version  string  `cramberry:"3" json:"version"`
	Region   *string `cramberry:"4,omitempty" json:"region,omitempty"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *EventSource) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *EventSource) encodeTo(w *cramberry.Writer) {
	if m.Service != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Service)
	}
	if m.Instance != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Instance)
	}
	if m.Version != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Version)
	}
	if m.Region != nil {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.Region)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *EventSource) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *EventSource) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Service = r.ReadString()
		case 2:
			m.Instance = r.ReadString()
		case 3:
			m.Version = r.ReadString()
		case 4:
			var tmp string
			tmp = r.ReadString()
			m.Region = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Event represents a system event.
type Event struct {
	Id            string            `cramberry:"1" json:"id"`
	Type          EventType         `cramberry:"2" json:"type"`
	EntityType    string            `cramberry:"3" json:"entity_type"`
	EntityId      string            `cramberry:"4" json:"entity_id"`
	Source        EventSource       `cramberry:"5" json:"source"`
	Timestamp     Timestamp         `cramberry:"6" json:"timestamp"`
	Attributes    map[string]string `cramberry:"7" json:"attributes"`
	Payload       *[]byte           `cramberry:"8,omitempty" json:"payload,omitempty"`
	CorrelationId *string           `cramberry:"9,omitempty" json:"correlation_id,omitempty"`
	CausationId   *string           `cramberry:"10,omitempty" json:"causation_id,omitempty"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Event) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *Event) encodeTo(w *cramberry.Writer) {
	if m.Id != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Id)
	}
	w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
	m.Type.encodeTo(w)
	if m.EntityType != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.EntityType)
	}
	if m.EntityId != "" {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteString(m.EntityId)
	}
	w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
	m.Source.encodeTo(w)
	w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
	m.Timestamp.encodeTo(w)
	if m.Attributes != nil {
		w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Attributes)))
		for k, v := range m.Attributes {
			w.WriteString(k)
			w.WriteString(v)
		}
	}
	if m.Payload != nil {
		w.WriteCompactTag(8, cramberry.WireTypeV2Bytes)
		w.WriteBytes(*m.Payload)
	}
	if m.CorrelationId != nil {
		w.WriteCompactTag(9, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.CorrelationId)
	}
	if m.CausationId != nil {
		w.WriteCompactTag(10, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.CausationId)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Event) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *Event) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Id = r.ReadString()
		case 2:
			m.Type.decodeFrom(r)
		case 3:
			m.EntityType = r.ReadString()
		case 4:
			m.EntityId = r.ReadString()
		case 5:
			m.Source.decodeFrom(r)
		case 6:
			m.Timestamp.decodeFrom(r)
		case 7:
			n := int(r.ReadUvarint())
			m.Attributes = make(map[string]string, n)
			for i := 0; i < n; i++ {
				var k string
				k = r.ReadString()
				var v string
				v = r.ReadString()
				m.Attributes[k] = v
			}
		case 8:
			var tmp []byte
			tmp = r.ReadBytes()
			m.Payload = &tmp
		case 9:
			var tmp string
			tmp = r.ReadString()
			m.CorrelationId = &tmp
		case 10:
			var tmp string
			tmp = r.ReadString()
			m.CausationId = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// LogEntry represents a log message.
type LogEntry struct {
	Timestamp  Timestamp         `cramberry:"1" json:"timestamp"`
	Level      string            `cramberry:"2" json:"level"`
	Logger     string            `cramberry:"3" json:"logger"`
	Msg        string            `cramberry:"4" json:"msg"`
	Source     EventSource       `cramberry:"5" json:"source"`
	Fields     map[string]string `cramberry:"6" json:"fields"`
	StackTrace *string           `cramberry:"7,omitempty" json:"stack_trace,omitempty"`
	TraceId    *string           `cramberry:"8,omitempty" json:"trace_id,omitempty"`
	SpanId     *string           `cramberry:"9,omitempty" json:"span_id,omitempty"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *LogEntry) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *LogEntry) encodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.Timestamp.encodeTo(w)
	if m.Level != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Level)
	}
	if m.Logger != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Logger)
	}
	if m.Msg != "" {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Msg)
	}
	w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
	m.Source.encodeTo(w)
	if m.Fields != nil {
		w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Fields)))
		for k, v := range m.Fields {
			w.WriteString(k)
			w.WriteString(v)
		}
	}
	if m.StackTrace != nil {
		w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.StackTrace)
	}
	if m.TraceId != nil {
		w.WriteCompactTag(8, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.TraceId)
	}
	if m.SpanId != nil {
		w.WriteCompactTag(9, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.SpanId)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *LogEntry) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *LogEntry) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Timestamp.decodeFrom(r)
		case 2:
			m.Level = r.ReadString()
		case 3:
			m.Logger = r.ReadString()
		case 4:
			m.Msg = r.ReadString()
		case 5:
			m.Source.decodeFrom(r)
		case 6:
			n := int(r.ReadUvarint())
			m.Fields = make(map[string]string, n)
			for i := 0; i < n; i++ {
				var k string
				k = r.ReadString()
				var v string
				v = r.ReadString()
				m.Fields[k] = v
			}
		case 7:
			var tmp string
			tmp = r.ReadString()
			m.StackTrace = &tmp
		case 8:
			var tmp string
			tmp = r.ReadString()
			m.TraceId = &tmp
		case 9:
			var tmp string
			tmp = r.ReadString()
			m.SpanId = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// UserProfile is a comprehensive user profile for stress testing.
type UserProfile struct {
	Id             int64             `cramberry:"1" json:"id"`
	Username       string            `cramberry:"2" json:"username"`
	Email          string            `cramberry:"3" json:"email"`
	DisplayName    string            `cramberry:"4" json:"display_name"`
	Bio            *string           `cramberry:"5,omitempty" json:"bio,omitempty"`
	AvatarUrl      *string           `cramberry:"6,omitempty" json:"avatar_url,omitempty"`
	PersonalInfo   Person            `cramberry:"7" json:"personal_info"`
	AccountStatus  Status            `cramberry:"8" json:"account_status"`
	Roles          []string          `cramberry:"9" json:"roles"`
	Permissions    []string          `cramberry:"10" json:"permissions"`
	Preferences    map[string]string `cramberry:"11" json:"preferences"`
	Settings       map[string]string `cramberry:"12" json:"settings"`
	Organizations  []Organization    `cramberry:"13" json:"organizations"`
	Documents      []Document        `cramberry:"14" json:"documents"`
	RecentActivity []Event           `cramberry:"15" json:"recent_activity"`
	UsageMetrics   Metrics           `cramberry:"16" json:"usage_metrics"`
	CreatedAt      Timestamp         `cramberry:"17" json:"created_at"`
	LastLoginAt    Timestamp         `cramberry:"18" json:"last_login_at"`
	DeletedAt      *Timestamp        `cramberry:"19,omitempty" json:"deleted_at,omitempty"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *UserProfile) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *UserProfile) encodeTo(w *cramberry.Writer) {
	if m.Id != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Id)
	}
	if m.Username != "" {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Username)
	}
	if m.Email != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Email)
	}
	if m.DisplayName != "" {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteString(m.DisplayName)
	}
	if m.Bio != nil {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.Bio)
	}
	if m.AvatarUrl != nil {
		w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.AvatarUrl)
	}
	w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
	m.PersonalInfo.encodeTo(w)
	w.WriteCompactTag(8, cramberry.WireTypeV2Bytes)
	m.AccountStatus.encodeTo(w)
	if len(m.Roles) > 0 {
		w.WriteCompactTag(9, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Roles)))
		for _, v := range m.Roles {
			w.WriteString(v)
		}
	}
	if len(m.Permissions) > 0 {
		w.WriteCompactTag(10, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Permissions)))
		for _, v := range m.Permissions {
			w.WriteString(v)
		}
	}
	if m.Preferences != nil {
		w.WriteCompactTag(11, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Preferences)))
		for k, v := range m.Preferences {
			w.WriteString(k)
			w.WriteString(v)
		}
	}
	if m.Settings != nil {
		w.WriteCompactTag(12, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Settings)))
		for k, v := range m.Settings {
			w.WriteString(k)
			w.WriteString(v)
		}
	}
	if len(m.Organizations) > 0 {
		w.WriteCompactTag(13, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Organizations)))
		for _, v := range m.Organizations {
			v.encodeTo(w)
		}
	}
	if len(m.Documents) > 0 {
		w.WriteCompactTag(14, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Documents)))
		for _, v := range m.Documents {
			v.encodeTo(w)
		}
	}
	if len(m.RecentActivity) > 0 {
		w.WriteCompactTag(15, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.RecentActivity)))
		for _, v := range m.RecentActivity {
			v.encodeTo(w)
		}
	}
	w.WriteCompactTag(16, cramberry.WireTypeV2Bytes)
	m.UsageMetrics.encodeTo(w)
	w.WriteCompactTag(17, cramberry.WireTypeV2Bytes)
	m.CreatedAt.encodeTo(w)
	w.WriteCompactTag(18, cramberry.WireTypeV2Bytes)
	m.LastLoginAt.encodeTo(w)
	if m.DeletedAt != nil {
		w.WriteCompactTag(19, cramberry.WireTypeV2Bytes)
		m.DeletedAt.encodeTo(w)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *UserProfile) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *UserProfile) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Id = r.ReadInt64()
		case 2:
			m.Username = r.ReadString()
		case 3:
			m.Email = r.ReadString()
		case 4:
			m.DisplayName = r.ReadString()
		case 5:
			var tmp string
			tmp = r.ReadString()
			m.Bio = &tmp
		case 6:
			var tmp string
			tmp = r.ReadString()
			m.AvatarUrl = &tmp
		case 7:
			m.PersonalInfo.decodeFrom(r)
		case 8:
			m.AccountStatus.decodeFrom(r)
		case 9:
			n := int(r.ReadUvarint())
			m.Roles = make([]string, n)
			for i := 0; i < n; i++ {
				m.Roles[i] = r.ReadString()
			}
		case 10:
			n := int(r.ReadUvarint())
			m.Permissions = make([]string, n)
			for i := 0; i < n; i++ {
				m.Permissions[i] = r.ReadString()
			}
		case 11:
			n := int(r.ReadUvarint())
			m.Preferences = make(map[string]string, n)
			for i := 0; i < n; i++ {
				var k string
				k = r.ReadString()
				var v string
				v = r.ReadString()
				m.Preferences[k] = v
			}
		case 12:
			n := int(r.ReadUvarint())
			m.Settings = make(map[string]string, n)
			for i := 0; i < n; i++ {
				var k string
				k = r.ReadString()
				var v string
				v = r.ReadString()
				m.Settings[k] = v
			}
		case 13:
			n := int(r.ReadUvarint())
			m.Organizations = make([]Organization, n)
			for i := 0; i < n; i++ {
				m.Organizations[i].decodeFrom(r)
			}
		case 14:
			n := int(r.ReadUvarint())
			m.Documents = make([]Document, n)
			for i := 0; i < n; i++ {
				m.Documents[i].decodeFrom(r)
			}
		case 15:
			n := int(r.ReadUvarint())
			m.RecentActivity = make([]Event, n)
			for i := 0; i < n; i++ {
				m.RecentActivity[i].decodeFrom(r)
			}
		case 16:
			m.UsageMetrics.decodeFrom(r)
		case 17:
			m.CreatedAt.decodeFrom(r)
		case 18:
			m.LastLoginAt.decodeFrom(r)
		case 19:
			var tmp Timestamp
			tmp.decodeFrom(r)
			m.DeletedAt = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// BatchRequest contains multiple items for batch processing.
type BatchRequest struct {
	RequestId   string            `cramberry:"1" json:"request_id"`
	Items       []SmallMessage    `cramberry:"2" json:"items"`
	Headers     map[string]string `cramberry:"3" json:"headers"`
	SubmittedAt Timestamp         `cramberry:"4" json:"submitted_at"`
	Timeout     *Duration         `cramberry:"5,omitempty" json:"timeout,omitempty"`
	Priority    Priority          `cramberry:"6" json:"priority"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BatchRequest) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *BatchRequest) encodeTo(w *cramberry.Writer) {
	if m.RequestId != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.RequestId)
	}
	if len(m.Items) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Items)))
		for _, v := range m.Items {
			v.encodeTo(w)
		}
	}
	if m.Headers != nil {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Headers)))
		for k, v := range m.Headers {
			w.WriteString(k)
			w.WriteString(v)
		}
	}
	w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
	m.SubmittedAt.encodeTo(w)
	if m.Timeout != nil {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		m.Timeout.encodeTo(w)
	}
	w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
	m.Priority.encodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BatchRequest) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *BatchRequest) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.RequestId = r.ReadString()
		case 2:
			n := int(r.ReadUvarint())
			m.Items = make([]SmallMessage, n)
			for i := 0; i < n; i++ {
				m.Items[i].decodeFrom(r)
			}
		case 3:
			n := int(r.ReadUvarint())
			m.Headers = make(map[string]string, n)
			for i := 0; i < n; i++ {
				var k string
				k = r.ReadString()
				var v string
				v = r.ReadString()
				m.Headers[k] = v
			}
		case 4:
			m.SubmittedAt.decodeFrom(r)
		case 5:
			var tmp Duration
			tmp.decodeFrom(r)
			m.Timeout = &tmp
		case 6:
			m.Priority.decodeFrom(r)
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// BatchResponse contains results from batch processing.
type BatchResponse struct {
	RequestId         string         `cramberry:"1" json:"request_id"`
	Results           []SmallMessage `cramberry:"2" json:"results"`
	Errors            []string       `cramberry:"3" json:"errors"`
	ProcessingMetrics Metrics        `cramberry:"4" json:"processing_metrics"`
	ProcessingTime    Duration       `cramberry:"5" json:"processing_time"`
	CompletedAt       Timestamp      `cramberry:"6" json:"completed_at"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BatchResponse) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *BatchResponse) encodeTo(w *cramberry.Writer) {
	if m.RequestId != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.RequestId)
	}
	if len(m.Results) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Results)))
		for _, v := range m.Results {
			v.encodeTo(w)
		}
	}
	if len(m.Errors) > 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Errors)))
		for _, v := range m.Errors {
			w.WriteString(v)
		}
	}
	w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
	m.ProcessingMetrics.encodeTo(w)
	w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
	m.ProcessingTime.encodeTo(w)
	w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
	m.CompletedAt.encodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BatchResponse) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *BatchResponse) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.RequestId = r.ReadString()
		case 2:
			n := int(r.ReadUvarint())
			m.Results = make([]SmallMessage, n)
			for i := 0; i < n; i++ {
				m.Results[i].decodeFrom(r)
			}
		case 3:
			n := int(r.ReadUvarint())
			m.Errors = make([]string, n)
			for i := 0; i < n; i++ {
				m.Errors[i] = r.ReadString()
			}
		case 4:
			m.ProcessingMetrics.decodeFrom(r)
		case 5:
			m.ProcessingTime.decodeFrom(r)
		case 6:
			m.CompletedAt.decodeFrom(r)
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}
