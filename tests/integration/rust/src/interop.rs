// Code generated by cramberry. DO NOT EDIT.
// Source: /Volumes/Tendermint/stealth/cramberry/tests/testdata/interop.cram

use serde::{Deserialize, Serialize};
use cramberry::{Reader, Result, WireType, Writer};



/// Status enum for testing enum serialization.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
#[derive(Serialize, Deserialize)]
#[repr(i32)]
pub enum Status {
#[default]
Unknown = 0,
Active = 1,
Inactive = 2,
Pending = 3,
}

impl Status {
    pub fn from_i32(value: i32) -> Option<Self> {
        match value {
            0 => Some(Self::Unknown),
            1 => Some(Self::Active),
            2 => Some(Self::Inactive),
            3 => Some(Self::Pending),
            _ => None,
        }
    }
}



/// ScalarTypes tests all scalar type serialization.
#[derive(Debug, Clone, PartialEq, Default)]
#[derive(Serialize, Deserialize)]
pub struct ScalarTypes {
    #[serde(rename = "bool_val")]
    pub bool_val: bool,
    #[serde(rename = "int32_val")]
    pub int32_val: i32,
    #[serde(rename = "int64_val")]
    pub int64_val: i64,
    #[serde(rename = "uint32_val")]
    pub uint32_val: u32,
    #[serde(rename = "uint64_val")]
    pub uint64_val: u64,
    #[serde(rename = "float32_val")]
    pub float32_val: f32,
    #[serde(rename = "float64_val")]
    pub float64_val: f64,
    #[serde(rename = "string_val")]
    pub string_val: String,
    #[serde(rename = "bytes_val")]
    pub bytes_val: Vec<u8>,
}

/// Encodes a ScalarTypes to the writer.
pub fn encode_scalar_types(writer: &mut Writer, msg: &ScalarTypes) -> Result<()> {
    // Write field count
    writer.write_varint(9)?;

    // Field 1: bool_val
    writer.write_tag(1, WireType::Varint)?;
    writer.write_bool(msg.bool_val)?;

    // Field 2: int32_val
    writer.write_tag(2, WireType::Varint)?;
    writer.write_svarint(msg.int32_val)?;

    // Field 3: int64_val
    writer.write_tag(3, WireType::Varint)?;
    writer.write_svarint64(msg.int64_val)?;

    // Field 4: uint32_val
    writer.write_tag(4, WireType::Varint)?;
    writer.write_varint(msg.uint32_val)?;

    // Field 5: uint64_val
    writer.write_tag(5, WireType::Varint)?;
    writer.write_varint64(msg.uint64_val)?;

    // Field 6: float32_val
    writer.write_tag(6, WireType::Fixed32)?;
    writer.write_float32(msg.float32_val)?;

    // Field 7: float64_val
    writer.write_tag(7, WireType::Fixed64)?;
    writer.write_float64(msg.float64_val)?;

    // Field 8: string_val
    writer.write_tag(8, WireType::Bytes)?;
    writer.write_string(&msg.string_val)?;

    // Field 9: bytes_val
    writer.write_tag(9, WireType::Bytes)?;
    writer.write_length_prefixed_bytes(&msg.bytes_val)?;

    Ok(())
}

/// Decodes a ScalarTypes from the reader.
pub fn decode_scalar_types(reader: &mut Reader) -> Result<ScalarTypes> {
    let field_count = reader.read_varint()?;
    let mut bool_val: bool = Default::default();
    let mut int32_val: i32 = Default::default();
    let mut int64_val: i64 = Default::default();
    let mut uint32_val: u32 = Default::default();
    let mut uint64_val: u64 = Default::default();
    let mut float32_val: f32 = Default::default();
    let mut float64_val: f64 = Default::default();
    let mut string_val: String = Default::default();
    let mut bytes_val: Vec<u8> = Default::default();

    for _ in 0..field_count {
        let tag = reader.read_tag()?;
        match tag.field_number {
            1 => bool_val = reader.read_bool()?,
            2 => int32_val = reader.read_svarint()?,
            3 => int64_val = reader.read_svarint64()?,
            4 => uint32_val = reader.read_varint()?,
            5 => uint64_val = reader.read_varint64()?,
            6 => float32_val = reader.read_float32()?,
            7 => float64_val = reader.read_float64()?,
            8 => string_val = reader.read_string()?.to_string(),
            9 => bytes_val = reader.read_length_prefixed_bytes()?.to_vec(),
            _ => reader.skip_field(tag.wire_type)?,
        }
    }

    Ok(ScalarTypes {
        bool_val,
        int32_val,
        int64_val,
        uint32_val,
        uint64_val,
        float32_val,
        float64_val,
        string_val,
        bytes_val,
    })
}

/// Marshals a ScalarTypes to bytes.
pub fn marshal_scalar_types(msg: &ScalarTypes) -> Result<Vec<u8>> {
    let mut writer = Writer::new();
    encode_scalar_types(&mut writer, msg)?;
    Ok(writer.into_bytes())
}

/// Unmarshals a ScalarTypes from bytes.
pub fn unmarshal_scalar_types(data: &[u8]) -> Result<ScalarTypes> {
    let mut reader = Reader::new(data);
    decode_scalar_types(&mut reader)
}


/// RepeatedTypes tests repeated field serialization.
#[derive(Debug, Clone, PartialEq, Default)]
#[derive(Serialize, Deserialize)]
pub struct RepeatedTypes {
    #[serde(rename = "int32_list")]
    pub int32_list: Vec<i32>,
    #[serde(rename = "string_list")]
    pub string_list: Vec<String>,
    #[serde(rename = "bytes_list")]
    pub bytes_list: Vec<Vec<u8>>,
}

/// Encodes a RepeatedTypes to the writer.
pub fn encode_repeated_types(writer: &mut Writer, msg: &RepeatedTypes) -> Result<()> {
    // Write field count
    writer.write_varint(3)?;

    // Field 1: int32_list
    writer.write_tag(1, WireType::Varint)?;
    {
        let mut sub_writer = Writer::new();
        sub_writer.write_varint(msg.int32_list.len() as u32)?;
        for elem in &msg.int32_list {
            sub_writer.write_svarint(*elem)?;
        }
        writer.write_length_prefixed_bytes(sub_writer.as_bytes())
    }?;

    // Field 2: string_list
    writer.write_tag(2, WireType::Bytes)?;
    {
        let mut sub_writer = Writer::new();
        sub_writer.write_varint(msg.string_list.len() as u32)?;
        for elem in &msg.string_list {
            sub_writer.write_string(elem)?;
        }
        writer.write_length_prefixed_bytes(sub_writer.as_bytes())
    }?;

    // Field 3: bytes_list
    writer.write_tag(3, WireType::Bytes)?;
    {
        let mut sub_writer = Writer::new();
        sub_writer.write_varint(msg.bytes_list.len() as u32)?;
        for elem in &msg.bytes_list {
            sub_writer.write_length_prefixed_bytes(elem)?;
        }
        writer.write_length_prefixed_bytes(sub_writer.as_bytes())
    }?;

    Ok(())
}

/// Decodes a RepeatedTypes from the reader.
pub fn decode_repeated_types(reader: &mut Reader) -> Result<RepeatedTypes> {
    let field_count = reader.read_varint()?;
    let mut int32_list: Vec<i32> = Default::default();
    let mut string_list: Vec<String> = Default::default();
    let mut bytes_list: Vec<Vec<u8>> = Default::default();

    for _ in 0..field_count {
        let tag = reader.read_tag()?;
        match tag.field_number {
            1 => int32_list = {
            let data = reader.read_length_prefixed_bytes()?;
            let mut sub_reader = Reader::new(data);
            let len = sub_reader.read_varint()? as usize;
            let mut result = Vec::with_capacity(len);
            for _ in 0..len {
                result.push(reader.read_svarint()?);
            }
            result
        },
            2 => string_list = {
            let data = reader.read_length_prefixed_bytes()?;
            let mut sub_reader = Reader::new(data);
            let len = sub_reader.read_varint()? as usize;
            let mut result = Vec::with_capacity(len);
            for _ in 0..len {
                result.push(reader.read_string()?.to_string());
            }
            result
        },
            3 => bytes_list = {
            let data = reader.read_length_prefixed_bytes()?;
            let mut sub_reader = Reader::new(data);
            let len = sub_reader.read_varint()? as usize;
            let mut result = Vec::with_capacity(len);
            for _ in 0..len {
                result.push(reader.read_length_prefixed_bytes()?.to_vec());
            }
            result
        },
            _ => reader.skip_field(tag.wire_type)?,
        }
    }

    Ok(RepeatedTypes {
        int32_list,
        string_list,
        bytes_list,
    })
}

/// Marshals a RepeatedTypes to bytes.
pub fn marshal_repeated_types(msg: &RepeatedTypes) -> Result<Vec<u8>> {
    let mut writer = Writer::new();
    encode_repeated_types(&mut writer, msg)?;
    Ok(writer.into_bytes())
}

/// Unmarshals a RepeatedTypes from bytes.
pub fn unmarshal_repeated_types(data: &[u8]) -> Result<RepeatedTypes> {
    let mut reader = Reader::new(data);
    decode_repeated_types(&mut reader)
}


/// NestedMessage tests nested message serialization.
#[derive(Debug, Clone, PartialEq, Default)]
#[derive(Serialize, Deserialize)]
pub struct NestedMessage {
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "value")]
    pub value: i32,
}

/// Encodes a NestedMessage to the writer.
pub fn encode_nested_message(writer: &mut Writer, msg: &NestedMessage) -> Result<()> {
    // Write field count
    writer.write_varint(2)?;

    // Field 1: name
    writer.write_tag(1, WireType::Bytes)?;
    writer.write_string(&msg.name)?;

    // Field 2: value
    writer.write_tag(2, WireType::Varint)?;
    writer.write_svarint(msg.value)?;

    Ok(())
}

/// Decodes a NestedMessage from the reader.
pub fn decode_nested_message(reader: &mut Reader) -> Result<NestedMessage> {
    let field_count = reader.read_varint()?;
    let mut name: String = Default::default();
    let mut value: i32 = Default::default();

    for _ in 0..field_count {
        let tag = reader.read_tag()?;
        match tag.field_number {
            1 => name = reader.read_string()?.to_string(),
            2 => value = reader.read_svarint()?,
            _ => reader.skip_field(tag.wire_type)?,
        }
    }

    Ok(NestedMessage {
        name,
        value,
    })
}

/// Marshals a NestedMessage to bytes.
pub fn marshal_nested_message(msg: &NestedMessage) -> Result<Vec<u8>> {
    let mut writer = Writer::new();
    encode_nested_message(&mut writer, msg)?;
    Ok(writer.into_bytes())
}

/// Unmarshals a NestedMessage from bytes.
pub fn unmarshal_nested_message(data: &[u8]) -> Result<NestedMessage> {
    let mut reader = Reader::new(data);
    decode_nested_message(&mut reader)
}


/// ComplexTypes tests complex type serialization.
#[derive(Debug, Clone, PartialEq, Default)]
#[derive(Serialize, Deserialize)]
pub struct ComplexTypes {
    #[serde(rename = "status")]
    pub status: Status,
    #[serde(rename = "optional_nested")]
    pub optional_nested: Option<Box<NestedMessage>>,
    #[serde(rename = "required_nested")]
    pub required_nested: NestedMessage,
    #[serde(rename = "nested_list")]
    pub nested_list: Vec<NestedMessage>,
    #[serde(rename = "string_int_map")]
    pub string_int_map: std::collections::HashMap<String, i32>,
    #[serde(rename = "int_string_map")]
    pub int_string_map: std::collections::HashMap<i32, String>,
}

/// Encodes a ComplexTypes to the writer.
pub fn encode_complex_types(writer: &mut Writer, msg: &ComplexTypes) -> Result<()> {
    // Write field count
    writer.write_varint(6)?;

    // Field 1: status
    writer.write_tag(1, WireType::Varint)?;
    writer.write_svarint(msg.status as i32)?;

    // Field 2: optional_nested
    writer.write_tag(2, WireType::TypeRef)?;
    if let Some(inner) = &msg.optional_nested {
        encode_nested_message(writer, &inner)
    } else {
        Ok(())
    }?;

    // Field 3: required_nested
    writer.write_tag(3, WireType::Bytes)?;
    encode_nested_message(writer, &msg.required_nested)?;

    // Field 4: nested_list
    writer.write_tag(4, WireType::Bytes)?;
    {
        let mut sub_writer = Writer::new();
        sub_writer.write_varint(msg.nested_list.len() as u32)?;
        for elem in &msg.nested_list {
            encode_nested_message(&mut sub_writer, elem)?;
        }
        writer.write_length_prefixed_bytes(sub_writer.as_bytes())
    }?;

    // Field 5: string_int_map
    writer.write_tag(5, WireType::Bytes)?;
    {
        let mut sub_writer = Writer::new();
        sub_writer.write_varint(msg.string_int_map.len() as u32)?;
        for (k, v) in &msg.string_int_map {
            sub_writer.write_string(k)?;
            sub_writer.write_svarint(*v)?;
        }
        writer.write_length_prefixed_bytes(sub_writer.as_bytes())
    }?;

    // Field 6: int_string_map
    writer.write_tag(6, WireType::Bytes)?;
    {
        let mut sub_writer = Writer::new();
        sub_writer.write_varint(msg.int_string_map.len() as u32)?;
        for (k, v) in &msg.int_string_map {
            sub_writer.write_svarint(*k)?;
            sub_writer.write_string(v)?;
        }
        writer.write_length_prefixed_bytes(sub_writer.as_bytes())
    }?;

    Ok(())
}

/// Decodes a ComplexTypes from the reader.
pub fn decode_complex_types(reader: &mut Reader) -> Result<ComplexTypes> {
    let field_count = reader.read_varint()?;
    let mut status: Status = Default::default();
    let mut optional_nested: Option<Box<NestedMessage>> = Default::default();
    let mut required_nested: NestedMessage = Default::default();
    let mut nested_list: Vec<NestedMessage> = Default::default();
    let mut string_int_map: std::collections::HashMap<String, i32> = Default::default();
    let mut int_string_map: std::collections::HashMap<i32, String> = Default::default();

    for _ in 0..field_count {
        let tag = reader.read_tag()?;
        match tag.field_number {
            1 => status = Status::from_i32(reader.read_svarint()?).unwrap_or(Status::Unknown),
            2 => optional_nested = Some(Box::new(decode_nested_message(reader)?)),
            3 => required_nested = decode_nested_message(reader)?,
            4 => nested_list = {
            let data = reader.read_length_prefixed_bytes()?;
            let mut sub_reader = Reader::new(data);
            let len = sub_reader.read_varint()? as usize;
            let mut result = Vec::with_capacity(len);
            for _ in 0..len {
                result.push(decode_nested_message(reader)?);
            }
            result
        },
            5 => string_int_map = {
            let data = reader.read_length_prefixed_bytes()?;
            let mut sub_reader = Reader::new(data);
            let len = sub_reader.read_varint()? as usize;
            let mut result = std::collections::HashMap::with_capacity(len);
            for _ in 0..len {
                let k = reader.read_string()?.to_string();
                let v = reader.read_svarint()?;
                result.insert(k, v);
            }
            result
        },
            6 => int_string_map = {
            let data = reader.read_length_prefixed_bytes()?;
            let mut sub_reader = Reader::new(data);
            let len = sub_reader.read_varint()? as usize;
            let mut result = std::collections::HashMap::with_capacity(len);
            for _ in 0..len {
                let k = reader.read_svarint()?;
                let v = reader.read_string()?.to_string();
                result.insert(k, v);
            }
            result
        },
            _ => reader.skip_field(tag.wire_type)?,
        }
    }

    Ok(ComplexTypes {
        status,
        optional_nested,
        required_nested,
        nested_list,
        string_int_map,
        int_string_map,
    })
}

/// Marshals a ComplexTypes to bytes.
pub fn marshal_complex_types(msg: &ComplexTypes) -> Result<Vec<u8>> {
    let mut writer = Writer::new();
    encode_complex_types(&mut writer, msg)?;
    Ok(writer.into_bytes())
}

/// Unmarshals a ComplexTypes from bytes.
pub fn unmarshal_complex_types(data: &[u8]) -> Result<ComplexTypes> {
    let mut reader = Reader::new(data);
    decode_complex_types(&mut reader)
}


/// EdgeCases tests edge case values.
#[derive(Debug, Clone, PartialEq, Default)]
#[derive(Serialize, Deserialize)]
pub struct EdgeCases {
    #[serde(rename = "zero_int")]
    pub zero_int: i32,
    #[serde(rename = "negative_one")]
    pub negative_one: i32,
    #[serde(rename = "max_int32")]
    pub max_int32: i32,
    #[serde(rename = "min_int32")]
    pub min_int32: i32,
    #[serde(rename = "max_int64")]
    pub max_int64: i64,
    #[serde(rename = "min_int64")]
    pub min_int64: i64,
    #[serde(rename = "max_uint32")]
    pub max_uint32: u32,
    #[serde(rename = "max_uint64")]
    pub max_uint64: u64,
    #[serde(rename = "empty_string")]
    pub empty_string: String,
    #[serde(rename = "unicode_string")]
    pub unicode_string: String,
    #[serde(rename = "empty_bytes")]
    pub empty_bytes: Vec<u8>,
}

/// Encodes a EdgeCases to the writer.
pub fn encode_edge_cases(writer: &mut Writer, msg: &EdgeCases) -> Result<()> {
    // Write field count
    writer.write_varint(11)?;

    // Field 1: zero_int
    writer.write_tag(1, WireType::Varint)?;
    writer.write_svarint(msg.zero_int)?;

    // Field 2: negative_one
    writer.write_tag(2, WireType::Varint)?;
    writer.write_svarint(msg.negative_one)?;

    // Field 3: max_int32
    writer.write_tag(3, WireType::Varint)?;
    writer.write_svarint(msg.max_int32)?;

    // Field 4: min_int32
    writer.write_tag(4, WireType::Varint)?;
    writer.write_svarint(msg.min_int32)?;

    // Field 5: max_int64
    writer.write_tag(5, WireType::Varint)?;
    writer.write_svarint64(msg.max_int64)?;

    // Field 6: min_int64
    writer.write_tag(6, WireType::Varint)?;
    writer.write_svarint64(msg.min_int64)?;

    // Field 7: max_uint32
    writer.write_tag(7, WireType::Varint)?;
    writer.write_varint(msg.max_uint32)?;

    // Field 8: max_uint64
    writer.write_tag(8, WireType::Varint)?;
    writer.write_varint64(msg.max_uint64)?;

    // Field 9: empty_string
    writer.write_tag(9, WireType::Bytes)?;
    writer.write_string(&msg.empty_string)?;

    // Field 10: unicode_string
    writer.write_tag(10, WireType::Bytes)?;
    writer.write_string(&msg.unicode_string)?;

    // Field 11: empty_bytes
    writer.write_tag(11, WireType::Bytes)?;
    writer.write_length_prefixed_bytes(&msg.empty_bytes)?;

    Ok(())
}

/// Decodes a EdgeCases from the reader.
pub fn decode_edge_cases(reader: &mut Reader) -> Result<EdgeCases> {
    let field_count = reader.read_varint()?;
    let mut zero_int: i32 = Default::default();
    let mut negative_one: i32 = Default::default();
    let mut max_int32: i32 = Default::default();
    let mut min_int32: i32 = Default::default();
    let mut max_int64: i64 = Default::default();
    let mut min_int64: i64 = Default::default();
    let mut max_uint32: u32 = Default::default();
    let mut max_uint64: u64 = Default::default();
    let mut empty_string: String = Default::default();
    let mut unicode_string: String = Default::default();
    let mut empty_bytes: Vec<u8> = Default::default();

    for _ in 0..field_count {
        let tag = reader.read_tag()?;
        match tag.field_number {
            1 => zero_int = reader.read_svarint()?,
            2 => negative_one = reader.read_svarint()?,
            3 => max_int32 = reader.read_svarint()?,
            4 => min_int32 = reader.read_svarint()?,
            5 => max_int64 = reader.read_svarint64()?,
            6 => min_int64 = reader.read_svarint64()?,
            7 => max_uint32 = reader.read_varint()?,
            8 => max_uint64 = reader.read_varint64()?,
            9 => empty_string = reader.read_string()?.to_string(),
            10 => unicode_string = reader.read_string()?.to_string(),
            11 => empty_bytes = reader.read_length_prefixed_bytes()?.to_vec(),
            _ => reader.skip_field(tag.wire_type)?,
        }
    }

    Ok(EdgeCases {
        zero_int,
        negative_one,
        max_int32,
        min_int32,
        max_int64,
        min_int64,
        max_uint32,
        max_uint64,
        empty_string,
        unicode_string,
        empty_bytes,
    })
}

/// Marshals a EdgeCases to bytes.
pub fn marshal_edge_cases(msg: &EdgeCases) -> Result<Vec<u8>> {
    let mut writer = Writer::new();
    encode_edge_cases(&mut writer, msg)?;
    Ok(writer.into_bytes())
}

/// Unmarshals a EdgeCases from bytes.
pub fn unmarshal_edge_cases(data: &[u8]) -> Result<EdgeCases> {
    let mut reader = Reader::new(data);
    decode_edge_cases(&mut reader)
}


/// AllFieldNumbers tests various field numbers including large ones.
#[derive(Debug, Clone, PartialEq, Default)]
#[derive(Serialize, Deserialize)]
pub struct AllFieldNumbers {
    #[serde(rename = "field_1")]
    pub field_1: i32,
    #[serde(rename = "field_15")]
    pub field_15: i32,
    #[serde(rename = "field_16")]
    pub field_16: i32,
    #[serde(rename = "field_127")]
    pub field_127: i32,
    #[serde(rename = "field_128")]
    pub field_128: i32,
    #[serde(rename = "field_1000")]
    pub field_1000: i32,
}

/// Encodes a AllFieldNumbers to the writer.
pub fn encode_all_field_numbers(writer: &mut Writer, msg: &AllFieldNumbers) -> Result<()> {
    // Write field count
    writer.write_varint(6)?;

    // Field 1: field_1
    writer.write_tag(1, WireType::Varint)?;
    writer.write_svarint(msg.field_1)?;

    // Field 15: field_15
    writer.write_tag(15, WireType::Varint)?;
    writer.write_svarint(msg.field_15)?;

    // Field 16: field_16
    writer.write_tag(16, WireType::Varint)?;
    writer.write_svarint(msg.field_16)?;

    // Field 127: field_127
    writer.write_tag(127, WireType::Varint)?;
    writer.write_svarint(msg.field_127)?;

    // Field 128: field_128
    writer.write_tag(128, WireType::Varint)?;
    writer.write_svarint(msg.field_128)?;

    // Field 1000: field_1000
    writer.write_tag(1000, WireType::Varint)?;
    writer.write_svarint(msg.field_1000)?;

    Ok(())
}

/// Decodes a AllFieldNumbers from the reader.
pub fn decode_all_field_numbers(reader: &mut Reader) -> Result<AllFieldNumbers> {
    let field_count = reader.read_varint()?;
    let mut field_1: i32 = Default::default();
    let mut field_15: i32 = Default::default();
    let mut field_16: i32 = Default::default();
    let mut field_127: i32 = Default::default();
    let mut field_128: i32 = Default::default();
    let mut field_1000: i32 = Default::default();

    for _ in 0..field_count {
        let tag = reader.read_tag()?;
        match tag.field_number {
            1 => field_1 = reader.read_svarint()?,
            15 => field_15 = reader.read_svarint()?,
            16 => field_16 = reader.read_svarint()?,
            127 => field_127 = reader.read_svarint()?,
            128 => field_128 = reader.read_svarint()?,
            1000 => field_1000 = reader.read_svarint()?,
            _ => reader.skip_field(tag.wire_type)?,
        }
    }

    Ok(AllFieldNumbers {
        field_1,
        field_15,
        field_16,
        field_127,
        field_128,
        field_1000,
    })
}

/// Marshals a AllFieldNumbers to bytes.
pub fn marshal_all_field_numbers(msg: &AllFieldNumbers) -> Result<Vec<u8>> {
    let mut writer = Writer::new();
    encode_all_field_numbers(&mut writer, msg)?;
    Ok(writer.into_bytes())
}

/// Unmarshals a AllFieldNumbers from bytes.
pub fn unmarshal_all_field_numbers(data: &[u8]) -> Result<AllFieldNumbers> {
    let mut reader = Reader::new(data);
    decode_all_field_numbers(&mut reader)
}



