// Code generated by cramberry. DO NOT EDIT.
// Source: /Volumes/Tendermint/stealth/cramberry/tests/testdata/interop.cram

package interop

import (
	"github.com/blockberries/cramberry/pkg/cramberry"
)

// Status enum for testing enum serialization.
type Status int32

const (
	StatusUnknown  Status = 0
	StatusActive   Status = 1
	StatusInactive Status = 2
	StatusPending  Status = 3
)

// String returns the string representation of the enum value.
func (e Status) String() string {
	switch e {
	case StatusUnknown:
		return "UNKNOWN"
	case StatusActive:
		return "ACTIVE"
	case StatusInactive:
		return "INACTIVE"
	case StatusPending:
		return "PENDING"
	default:
		return "UNKNOWN"
	}
}

// IsValid returns true if the value is a valid enum value.
func (e Status) IsValid() bool {
	switch e {
	case StatusUnknown:
		return true
	case StatusActive:
		return true
	case StatusInactive:
		return true
	case StatusPending:
		return true
	default:
		return false
	}
}

// EncodeTo encodes the enum value directly to the writer.
func (e Status) EncodeTo(w *cramberry.Writer) {
	w.WriteInt32(int32(e))
}

// DecodeFrom decodes the enum value from the reader.
func (e *Status) DecodeFrom(r *cramberry.Reader) {
	*e = Status(r.ReadInt32())
}

// ScalarTypes tests all scalar type serialization.
type ScalarTypes struct {
	BoolVal    bool    `cramberry:"1" json:"bool_val"`
	Int32Val   int32   `cramberry:"2" json:"int32_val"`
	Int64Val   int64   `cramberry:"3" json:"int64_val"`
	Uint32Val  uint32  `cramberry:"4" json:"uint32_val"`
	Uint64Val  uint64  `cramberry:"5" json:"uint64_val"`
	Float32Val float32 `cramberry:"6" json:"float32_val"`
	Float64Val float64 `cramberry:"7" json:"float64_val"`
	StringVal  string  `cramberry:"8" json:"string_val"`
	BytesVal   []byte  `cramberry:"9" json:"bytes_val"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *ScalarTypes) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *ScalarTypes) EncodeTo(w *cramberry.Writer) {
	if m.BoolVal {
		w.WriteCompactTag(1, cramberry.WireTypeV2Varint)
		w.WriteBool(m.BoolVal)
	}
	if m.Int32Val != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Int32Val)
	}
	if m.Int64Val != 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Int64Val)
	}
	if m.Uint32Val != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2Varint)
		w.WriteUint32(m.Uint32Val)
	}
	if m.Uint64Val != 0 {
		w.WriteCompactTag(5, cramberry.WireTypeV2Varint)
		w.WriteUint64(m.Uint64Val)
	}
	if m.Float32Val != 0 {
		w.WriteCompactTag(6, cramberry.WireTypeV2Fixed32)
		w.WriteFloat32(m.Float32Val)
	}
	if m.Float64Val != 0 {
		w.WriteCompactTag(7, cramberry.WireTypeV2Fixed64)
		w.WriteFloat64(m.Float64Val)
	}
	if m.StringVal != "" {
		w.WriteCompactTag(8, cramberry.WireTypeV2Bytes)
		w.WriteString(m.StringVal)
	}
	if len(m.BytesVal) > 0 {
		w.WriteCompactTag(9, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.BytesVal)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *ScalarTypes) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *ScalarTypes) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.BoolVal = r.ReadBool()
		case 2:
			m.Int32Val = r.ReadInt32()
		case 3:
			m.Int64Val = r.ReadInt64()
		case 4:
			m.Uint32Val = r.ReadUint32()
		case 5:
			m.Uint64Val = r.ReadUint64()
		case 6:
			m.Float32Val = r.ReadFloat32()
		case 7:
			m.Float64Val = r.ReadFloat64()
		case 8:
			m.StringVal = r.ReadString()
		case 9:
			m.BytesVal = r.ReadBytes()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// RepeatedTypes tests repeated field serialization.
type RepeatedTypes struct {
	Int32List  []int32  `cramberry:"1" json:"int32_list"`
	StringList []string `cramberry:"2" json:"string_list"`
	BytesList  [][]byte `cramberry:"3" json:"bytes_list"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *RepeatedTypes) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *RepeatedTypes) EncodeTo(w *cramberry.Writer) {
	if len(m.Int32List) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Int32List)))
		for _, v := range m.Int32List {
			w.WriteInt32(v)
		}
	}
	if len(m.StringList) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.StringList)))
		for _, v := range m.StringList {
			w.WriteString(v)
		}
	}
	if len(m.BytesList) > 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.BytesList)))
		for _, v := range m.BytesList {
			w.WriteBytes(v)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *RepeatedTypes) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *RepeatedTypes) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := int(r.ReadUvarint())
			m.Int32List = make([]int32, n)
			for i := 0; i < n; i++ {
				m.Int32List[i] = r.ReadInt32()
			}
		case 2:
			n := int(r.ReadUvarint())
			m.StringList = make([]string, n)
			for i := 0; i < n; i++ {
				m.StringList[i] = r.ReadString()
			}
		case 3:
			n := int(r.ReadUvarint())
			m.BytesList = make([][]byte, n)
			for i := 0; i < n; i++ {
				m.BytesList[i] = r.ReadBytes()
			}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// NestedMessage tests nested message serialization.
type NestedMessage struct {
	Name  string `cramberry:"1" json:"name"`
	Value int32  `cramberry:"2" json:"value"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *NestedMessage) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *NestedMessage) EncodeTo(w *cramberry.Writer) {
	if m.Name != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.Name)
	}
	if m.Value != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Value)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *NestedMessage) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *NestedMessage) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Name = r.ReadString()
		case 2:
			m.Value = r.ReadInt32()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// ComplexTypes tests complex type serialization.
type ComplexTypes struct {
	Status         Status           `cramberry:"1" json:"status"`
	OptionalNested *NestedMessage   `cramberry:"2" json:"optional_nested"`
	RequiredNested NestedMessage    `cramberry:"3" json:"required_nested"`
	NestedList     []NestedMessage  `cramberry:"4" json:"nested_list"`
	StringIntMap   map[string]int32 `cramberry:"5" json:"string_int_map"`
	IntStringMap   map[int32]string `cramberry:"6" json:"int_string_map"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *ComplexTypes) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *ComplexTypes) EncodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.Status.EncodeTo(w)
	if m.OptionalNested != nil {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		m.OptionalNested.EncodeTo(w)
	}
	w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
	m.RequiredNested.EncodeTo(w)
	if len(m.NestedList) > 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.NestedList)))
		for _, v := range m.NestedList {
			v.EncodeTo(w)
		}
	}
	if m.StringIntMap != nil {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.StringIntMap)))
		for k, v := range m.StringIntMap {
			w.WriteString(k)
			w.WriteInt32(v)
		}
	}
	if m.IntStringMap != nil {
		w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.IntStringMap)))
		for k, v := range m.IntStringMap {
			w.WriteInt32(k)
			w.WriteString(v)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *ComplexTypes) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *ComplexTypes) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Status.DecodeFrom(r)
		case 2:
			{
				var v NestedMessage
				v.DecodeFrom(r)
				m.OptionalNested = &v
			}
		case 3:
			m.RequiredNested.DecodeFrom(r)
		case 4:
			n := int(r.ReadUvarint())
			m.NestedList = make([]NestedMessage, n)
			for i := 0; i < n; i++ {
				m.NestedList[i].DecodeFrom(r)
			}
		case 5:
			n := int(r.ReadUvarint())
			m.StringIntMap = make(map[string]int32, n)
			for i := 0; i < n; i++ {
				var k string
				k = r.ReadString()
				var v int32
				v = r.ReadInt32()
				m.StringIntMap[k] = v
			}
		case 6:
			n := int(r.ReadUvarint())
			m.IntStringMap = make(map[int32]string, n)
			for i := 0; i < n; i++ {
				var k int32
				k = r.ReadInt32()
				var v string
				v = r.ReadString()
				m.IntStringMap[k] = v
			}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// EdgeCases tests edge case values.
type EdgeCases struct {
	ZeroInt       int32  `cramberry:"1" json:"zero_int"`
	NegativeOne   int32  `cramberry:"2" json:"negative_one"`
	MaxInt32      int32  `cramberry:"3" json:"max_int32"`
	MinInt32      int32  `cramberry:"4" json:"min_int32"`
	MaxInt64      int64  `cramberry:"5" json:"max_int64"`
	MinInt64      int64  `cramberry:"6" json:"min_int64"`
	MaxUint32     uint32 `cramberry:"7" json:"max_uint32"`
	MaxUint64     uint64 `cramberry:"8" json:"max_uint64"`
	EmptyString   string `cramberry:"9" json:"empty_string"`
	UnicodeString string `cramberry:"10" json:"unicode_string"`
	EmptyBytes    []byte `cramberry:"11" json:"empty_bytes"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *EdgeCases) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *EdgeCases) EncodeTo(w *cramberry.Writer) {
	if m.ZeroInt != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.ZeroInt)
	}
	if m.NegativeOne != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.NegativeOne)
	}
	if m.MaxInt32 != 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.MaxInt32)
	}
	if m.MinInt32 != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.MinInt32)
	}
	if m.MaxInt64 != 0 {
		w.WriteCompactTag(5, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.MaxInt64)
	}
	if m.MinInt64 != 0 {
		w.WriteCompactTag(6, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.MinInt64)
	}
	if m.MaxUint32 != 0 {
		w.WriteCompactTag(7, cramberry.WireTypeV2Varint)
		w.WriteUint32(m.MaxUint32)
	}
	if m.MaxUint64 != 0 {
		w.WriteCompactTag(8, cramberry.WireTypeV2Varint)
		w.WriteUint64(m.MaxUint64)
	}
	if m.EmptyString != "" {
		w.WriteCompactTag(9, cramberry.WireTypeV2Bytes)
		w.WriteString(m.EmptyString)
	}
	if m.UnicodeString != "" {
		w.WriteCompactTag(10, cramberry.WireTypeV2Bytes)
		w.WriteString(m.UnicodeString)
	}
	if len(m.EmptyBytes) > 0 {
		w.WriteCompactTag(11, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.EmptyBytes)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *EdgeCases) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *EdgeCases) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.ZeroInt = r.ReadInt32()
		case 2:
			m.NegativeOne = r.ReadInt32()
		case 3:
			m.MaxInt32 = r.ReadInt32()
		case 4:
			m.MinInt32 = r.ReadInt32()
		case 5:
			m.MaxInt64 = r.ReadInt64()
		case 6:
			m.MinInt64 = r.ReadInt64()
		case 7:
			m.MaxUint32 = r.ReadUint32()
		case 8:
			m.MaxUint64 = r.ReadUint64()
		case 9:
			m.EmptyString = r.ReadString()
		case 10:
			m.UnicodeString = r.ReadString()
		case 11:
			m.EmptyBytes = r.ReadBytes()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// AllFieldNumbers tests various field numbers including large ones.
type AllFieldNumbers struct {
	Field1    int32 `cramberry:"1" json:"field_1"`
	Field15   int32 `cramberry:"15" json:"field_15"`
	Field16   int32 `cramberry:"16" json:"field_16"`
	Field127  int32 `cramberry:"127" json:"field_127"`
	Field128  int32 `cramberry:"128" json:"field_128"`
	Field1000 int32 `cramberry:"1000" json:"field_1000"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AllFieldNumbers) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *AllFieldNumbers) EncodeTo(w *cramberry.Writer) {
	if m.Field1 != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Field1)
	}
	if m.Field15 != 0 {
		w.WriteCompactTag(15, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Field15)
	}
	if m.Field16 != 0 {
		w.WriteCompactTag(16, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Field16)
	}
	if m.Field127 != 0 {
		w.WriteCompactTag(127, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Field127)
	}
	if m.Field128 != 0 {
		w.WriteCompactTag(128, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Field128)
	}
	if m.Field1000 != 0 {
		w.WriteCompactTag(1000, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Field1000)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AllFieldNumbers) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *AllFieldNumbers) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Field1 = r.ReadInt32()
		case 15:
			m.Field15 = r.ReadInt32()
		case 16:
			m.Field16 = r.ReadInt32()
		case 127:
			m.Field127 = r.ReadInt32()
		case 128:
			m.Field128 = r.ReadInt32()
		case 1000:
			m.Field1000 = r.ReadInt32()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}
