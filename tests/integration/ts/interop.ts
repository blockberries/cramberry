// Code generated by cramberry. DO NOT EDIT.
// Source: /Volumes/Tendermint/stealth/cramberry/tests/testdata/interop.cramberry

import { Writer, Reader, WireType } from '../../../typescript/src';

// Helper functions for encoding/decoding
function writeArray<T>(writer: Writer, arr: T[], writeElem: (w: Writer, v: T) => void): void {
  const subWriter = new Writer();
  subWriter.writeVarint(arr.length);
  for (const elem of arr) {
    writeElem(subWriter, elem);
  }
  writer.writeLengthPrefixedBytes(subWriter.bytes());
}

function readArray<T>(reader: Reader, readElem: (r: Reader) => T): T[] {
  const data = reader.readLengthPrefixedBytes();
  const subReader = new Reader(data);
  const len = subReader.readVarint();
  const result: T[] = [];
  for (let i = 0; i < len; i++) {
    result.push(readElem(subReader));
  }
  return result;
}

function writeMap<K, V>(writer: Writer, map: Map<K, V> | Record<string, V>, writeKey: (w: Writer, k: K) => void, writeVal: (w: Writer, v: V) => void): void {
  const subWriter = new Writer();
  const entries = map instanceof Map ? Array.from(map.entries()) : Object.entries(map);
  subWriter.writeVarint(entries.length);
  for (const [k, v] of entries) {
    writeKey(subWriter, k as K);
    writeVal(subWriter, v as V);
  }
  writer.writeLengthPrefixedBytes(subWriter.bytes());
}

function readMap<K, V>(reader: Reader, readKey: (r: Reader) => K, readVal: (r: Reader) => V): Map<K, V> {
  const data = reader.readLengthPrefixedBytes();
  const subReader = new Reader(data);
  const len = subReader.readVarint();
  const result = new Map<K, V>();
  for (let i = 0; i < len; i++) {
    const k = readKey(subReader);
    const v = readVal(subReader);
    result.set(k, v);
  }
  return result;
}



/** Status enum for testing enum serialization. */
export enum Status {
Unknown = 0,
Active = 1,
Inactive = 2,
Pending = 3,
}



/** ScalarTypes tests all scalar type serialization. */
export interface ScalarTypes {
boolVal: boolean;
int32Val: number;
int64Val: bigint;
uint32Val: number;
uint64Val: bigint;
float32Val: number;
float64Val: number;
stringVal: string;
bytesVal: Uint8Array;
}

/** Encodes a ScalarTypes to the writer. */
export function encodeScalarTypes(writer: Writer, msg: ScalarTypes): void {
  // Count non-empty fields
  let fieldCount = 0;
  if (msg.boolVal !== undefined && msg.boolVal !== null) fieldCount++;
  if (msg.int32Val !== undefined && msg.int32Val !== null) fieldCount++;
  if (msg.int64Val !== undefined && msg.int64Val !== null) fieldCount++;
  if (msg.uint32Val !== undefined && msg.uint32Val !== null) fieldCount++;
  if (msg.uint64Val !== undefined && msg.uint64Val !== null) fieldCount++;
  if (msg.float32Val !== undefined && msg.float32Val !== null) fieldCount++;
  if (msg.float64Val !== undefined && msg.float64Val !== null) fieldCount++;
  if (msg.stringVal !== undefined && msg.stringVal !== null) fieldCount++;
  if (msg.bytesVal !== undefined && msg.bytesVal !== null) fieldCount++;
  writer.writeVarint(fieldCount);

  // Field 1: bool_val
  if (msg.boolVal !== undefined && msg.boolVal !== null) {
    writer.writeTag(1, WireType.Varint);
    writer.writeBool(msg.boolVal);
  }

  // Field 2: int32_val
  if (msg.int32Val !== undefined && msg.int32Val !== null) {
    writer.writeTag(2, WireType.Varint);
    writer.writeSVarint(msg.int32Val);
  }

  // Field 3: int64_val
  if (msg.int64Val !== undefined && msg.int64Val !== null) {
    writer.writeTag(3, WireType.Varint);
    writer.writeSVarint64(msg.int64Val);
  }

  // Field 4: uint32_val
  if (msg.uint32Val !== undefined && msg.uint32Val !== null) {
    writer.writeTag(4, WireType.Varint);
    writer.writeVarint(msg.uint32Val);
  }

  // Field 5: uint64_val
  if (msg.uint64Val !== undefined && msg.uint64Val !== null) {
    writer.writeTag(5, WireType.Varint);
    writer.writeVarint64(msg.uint64Val);
  }

  // Field 6: float32_val
  if (msg.float32Val !== undefined && msg.float32Val !== null) {
    writer.writeTag(6, WireType.Fixed32);
    writer.writeFloat32(msg.float32Val);
  }

  // Field 7: float64_val
  if (msg.float64Val !== undefined && msg.float64Val !== null) {
    writer.writeTag(7, WireType.Fixed64);
    writer.writeFloat64(msg.float64Val);
  }

  // Field 8: string_val
  if (msg.stringVal !== undefined && msg.stringVal !== null) {
    writer.writeTag(8, WireType.Bytes);
    writer.writeString(msg.stringVal);
  }

  // Field 9: bytes_val
  if (msg.bytesVal !== undefined && msg.bytesVal !== null) {
    writer.writeTag(9, WireType.Bytes);
    writer.writeLengthPrefixedBytes(msg.bytesVal);
  }
}

/** Decodes a ScalarTypes from the reader. */
export function decodeScalarTypes(reader: Reader): ScalarTypes {
  const fieldCount = reader.readVarint();
  const result: Partial<ScalarTypes> = {};

  for (let i = 0; i < fieldCount; i++) {
    const tag = reader.readTag();
    switch (tag.fieldNumber) {
      case 1:
        result.boolVal = reader.readBool();
        break;
      case 2:
        result.int32Val = reader.readSVarint();
        break;
      case 3:
        result.int64Val = reader.readSVarint64();
        break;
      case 4:
        result.uint32Val = reader.readVarint();
        break;
      case 5:
        result.uint64Val = reader.readVarint64();
        break;
      case 6:
        result.float32Val = reader.readFloat32();
        break;
      case 7:
        result.float64Val = reader.readFloat64();
        break;
      case 8:
        result.stringVal = reader.readString();
        break;
      case 9:
        result.bytesVal = reader.readLengthPrefixedBytes();
        break;
      default:
        reader.skipField(tag.wireType);
    }
  }

  return result as ScalarTypes;
}

/** Marshals a ScalarTypes to bytes. */
export function marshalScalarTypes(msg: ScalarTypes): Uint8Array {
  const writer = new Writer();
  encodeScalarTypes(writer, msg);
  return writer.bytes();
}

/** Unmarshals a ScalarTypes from bytes. */
export function unmarshalScalarTypes(data: Uint8Array): ScalarTypes {
  const reader = new Reader(data);
  return decodeScalarTypes(reader);
}


/** RepeatedTypes tests repeated field serialization. */
export interface RepeatedTypes {
int32List: number[];
stringList: string[];
bytesList: Uint8Array[];
}

/** Encodes a RepeatedTypes to the writer. */
export function encodeRepeatedTypes(writer: Writer, msg: RepeatedTypes): void {
  // Count non-empty fields
  let fieldCount = 0;
  if (msg.int32List !== undefined && msg.int32List !== null) fieldCount++;
  if (msg.stringList !== undefined && msg.stringList !== null) fieldCount++;
  if (msg.bytesList !== undefined && msg.bytesList !== null) fieldCount++;
  writer.writeVarint(fieldCount);

  // Field 1: int32_list
  if (msg.int32List !== undefined && msg.int32List !== null) {
    writer.writeTag(1, WireType.Varint);
    writeArray(writer, msg.int32List, (w, v) => { w.writeSVarint(v) });
  }

  // Field 2: string_list
  if (msg.stringList !== undefined && msg.stringList !== null) {
    writer.writeTag(2, WireType.Bytes);
    writeArray(writer, msg.stringList, (w, v) => { w.writeString(v) });
  }

  // Field 3: bytes_list
  if (msg.bytesList !== undefined && msg.bytesList !== null) {
    writer.writeTag(3, WireType.Bytes);
    writeArray(writer, msg.bytesList, (w, v) => { w.writeLengthPrefixedBytes(v) });
  }
}

/** Decodes a RepeatedTypes from the reader. */
export function decodeRepeatedTypes(reader: Reader): RepeatedTypes {
  const fieldCount = reader.readVarint();
  const result: Partial<RepeatedTypes> = {};

  for (let i = 0; i < fieldCount; i++) {
    const tag = reader.readTag();
    switch (tag.fieldNumber) {
      case 1:
        result.int32List = readArray(reader, (r) => reader.readSVarint());
        break;
      case 2:
        result.stringList = readArray(reader, (r) => reader.readString());
        break;
      case 3:
        result.bytesList = readArray(reader, (r) => reader.readLengthPrefixedBytes());
        break;
      default:
        reader.skipField(tag.wireType);
    }
  }

  return result as RepeatedTypes;
}

/** Marshals a RepeatedTypes to bytes. */
export function marshalRepeatedTypes(msg: RepeatedTypes): Uint8Array {
  const writer = new Writer();
  encodeRepeatedTypes(writer, msg);
  return writer.bytes();
}

/** Unmarshals a RepeatedTypes from bytes. */
export function unmarshalRepeatedTypes(data: Uint8Array): RepeatedTypes {
  const reader = new Reader(data);
  return decodeRepeatedTypes(reader);
}


/** NestedMessage tests nested message serialization. */
export interface NestedMessage {
name: string;
value: number;
}

/** Encodes a NestedMessage to the writer. */
export function encodeNestedMessage(writer: Writer, msg: NestedMessage): void {
  // Count non-empty fields
  let fieldCount = 0;
  if (msg.name !== undefined && msg.name !== null) fieldCount++;
  if (msg.value !== undefined && msg.value !== null) fieldCount++;
  writer.writeVarint(fieldCount);

  // Field 1: name
  if (msg.name !== undefined && msg.name !== null) {
    writer.writeTag(1, WireType.Bytes);
    writer.writeString(msg.name);
  }

  // Field 2: value
  if (msg.value !== undefined && msg.value !== null) {
    writer.writeTag(2, WireType.Varint);
    writer.writeSVarint(msg.value);
  }
}

/** Decodes a NestedMessage from the reader. */
export function decodeNestedMessage(reader: Reader): NestedMessage {
  const fieldCount = reader.readVarint();
  const result: Partial<NestedMessage> = {};

  for (let i = 0; i < fieldCount; i++) {
    const tag = reader.readTag();
    switch (tag.fieldNumber) {
      case 1:
        result.name = reader.readString();
        break;
      case 2:
        result.value = reader.readSVarint();
        break;
      default:
        reader.skipField(tag.wireType);
    }
  }

  return result as NestedMessage;
}

/** Marshals a NestedMessage to bytes. */
export function marshalNestedMessage(msg: NestedMessage): Uint8Array {
  const writer = new Writer();
  encodeNestedMessage(writer, msg);
  return writer.bytes();
}

/** Unmarshals a NestedMessage from bytes. */
export function unmarshalNestedMessage(data: Uint8Array): NestedMessage {
  const reader = new Reader(data);
  return decodeNestedMessage(reader);
}


/** ComplexTypes tests complex type serialization. */
export interface ComplexTypes {
status: Status;
optionalNested: NestedMessage | null;
requiredNested: NestedMessage;
nestedList: NestedMessage[];
stringIntMap: Record<string, number>;
intStringMap: Map<number, string>;
}

/** Encodes a ComplexTypes to the writer. */
export function encodeComplexTypes(writer: Writer, msg: ComplexTypes): void {
  // Count non-empty fields
  let fieldCount = 0;
  if (msg.status !== undefined && msg.status !== null) fieldCount++;
  if (msg.optionalNested !== undefined && msg.optionalNested !== null) fieldCount++;
  if (msg.requiredNested !== undefined && msg.requiredNested !== null) fieldCount++;
  if (msg.nestedList !== undefined && msg.nestedList !== null) fieldCount++;
  if (msg.stringIntMap !== undefined && msg.stringIntMap !== null) fieldCount++;
  if (msg.intStringMap !== undefined && msg.intStringMap !== null) fieldCount++;
  writer.writeVarint(fieldCount);

  // Field 1: status
  if (msg.status !== undefined && msg.status !== null) {
    writer.writeTag(1, WireType.Varint);
    writer.writeSVarint(msg.status);
  }

  // Field 2: optional_nested
  if (msg.optionalNested !== undefined && msg.optionalNested !== null) {
    writer.writeTag(2, WireType.TypeRef);
    if (msg.optionalNested !== null) { encodeNestedMessage(writer, msg.optionalNested) };
  }

  // Field 3: required_nested
  if (msg.requiredNested !== undefined && msg.requiredNested !== null) {
    writer.writeTag(3, WireType.Bytes);
    encodeNestedMessage(writer, msg.requiredNested);
  }

  // Field 4: nested_list
  if (msg.nestedList !== undefined && msg.nestedList !== null) {
    writer.writeTag(4, WireType.Bytes);
    writeArray(writer, msg.nestedList, (w, v) => { encodeNestedMessage(w, v) });
  }

  // Field 5: string_int_map
  if (msg.stringIntMap !== undefined && msg.stringIntMap !== null) {
    writer.writeTag(5, WireType.Bytes);
    writeMap(writer, msg.stringIntMap, (w, k) => { w.writeString(k) }, (w, v) => { w.writeSVarint(v) });
  }

  // Field 6: int_string_map
  if (msg.intStringMap !== undefined && msg.intStringMap !== null) {
    writer.writeTag(6, WireType.Bytes);
    writeMap(writer, msg.intStringMap, (w, k) => { w.writeSVarint(k) }, (w, v) => { w.writeString(v) });
  }
}

/** Decodes a ComplexTypes from the reader. */
export function decodeComplexTypes(reader: Reader): ComplexTypes {
  const fieldCount = reader.readVarint();
  const result: Partial<ComplexTypes> = {};

  for (let i = 0; i < fieldCount; i++) {
    const tag = reader.readTag();
    switch (tag.fieldNumber) {
      case 1:
        result.status = reader.readSVarint();
        break;
      case 2:
        result.optionalNested = decodeNestedMessage(reader);
        break;
      case 3:
        result.requiredNested = decodeNestedMessage(reader);
        break;
      case 4:
        result.nestedList = readArray(reader, (r) => decodeNestedMessage(reader));
        break;
      case 5:
        result.stringIntMap = readMap(reader, (r) => reader.readString(), (r) => reader.readSVarint());
        break;
      case 6:
        result.intStringMap = readMap(reader, (r) => reader.readSVarint(), (r) => reader.readString());
        break;
      default:
        reader.skipField(tag.wireType);
    }
  }

  return result as ComplexTypes;
}

/** Marshals a ComplexTypes to bytes. */
export function marshalComplexTypes(msg: ComplexTypes): Uint8Array {
  const writer = new Writer();
  encodeComplexTypes(writer, msg);
  return writer.bytes();
}

/** Unmarshals a ComplexTypes from bytes. */
export function unmarshalComplexTypes(data: Uint8Array): ComplexTypes {
  const reader = new Reader(data);
  return decodeComplexTypes(reader);
}


/** EdgeCases tests edge case values. */
export interface EdgeCases {
zeroInt: number;
negativeOne: number;
maxInt32: number;
minInt32: number;
maxInt64: bigint;
minInt64: bigint;
maxUint32: number;
maxUint64: bigint;
emptyString: string;
unicodeString: string;
emptyBytes: Uint8Array;
}

/** Encodes a EdgeCases to the writer. */
export function encodeEdgeCases(writer: Writer, msg: EdgeCases): void {
  // Count non-empty fields
  let fieldCount = 0;
  if (msg.zeroInt !== undefined && msg.zeroInt !== null) fieldCount++;
  if (msg.negativeOne !== undefined && msg.negativeOne !== null) fieldCount++;
  if (msg.maxInt32 !== undefined && msg.maxInt32 !== null) fieldCount++;
  if (msg.minInt32 !== undefined && msg.minInt32 !== null) fieldCount++;
  if (msg.maxInt64 !== undefined && msg.maxInt64 !== null) fieldCount++;
  if (msg.minInt64 !== undefined && msg.minInt64 !== null) fieldCount++;
  if (msg.maxUint32 !== undefined && msg.maxUint32 !== null) fieldCount++;
  if (msg.maxUint64 !== undefined && msg.maxUint64 !== null) fieldCount++;
  if (msg.emptyString !== undefined && msg.emptyString !== null) fieldCount++;
  if (msg.unicodeString !== undefined && msg.unicodeString !== null) fieldCount++;
  if (msg.emptyBytes !== undefined && msg.emptyBytes !== null) fieldCount++;
  writer.writeVarint(fieldCount);

  // Field 1: zero_int
  if (msg.zeroInt !== undefined && msg.zeroInt !== null) {
    writer.writeTag(1, WireType.Varint);
    writer.writeSVarint(msg.zeroInt);
  }

  // Field 2: negative_one
  if (msg.negativeOne !== undefined && msg.negativeOne !== null) {
    writer.writeTag(2, WireType.Varint);
    writer.writeSVarint(msg.negativeOne);
  }

  // Field 3: max_int32
  if (msg.maxInt32 !== undefined && msg.maxInt32 !== null) {
    writer.writeTag(3, WireType.Varint);
    writer.writeSVarint(msg.maxInt32);
  }

  // Field 4: min_int32
  if (msg.minInt32 !== undefined && msg.minInt32 !== null) {
    writer.writeTag(4, WireType.Varint);
    writer.writeSVarint(msg.minInt32);
  }

  // Field 5: max_int64
  if (msg.maxInt64 !== undefined && msg.maxInt64 !== null) {
    writer.writeTag(5, WireType.Varint);
    writer.writeSVarint64(msg.maxInt64);
  }

  // Field 6: min_int64
  if (msg.minInt64 !== undefined && msg.minInt64 !== null) {
    writer.writeTag(6, WireType.Varint);
    writer.writeSVarint64(msg.minInt64);
  }

  // Field 7: max_uint32
  if (msg.maxUint32 !== undefined && msg.maxUint32 !== null) {
    writer.writeTag(7, WireType.Varint);
    writer.writeVarint(msg.maxUint32);
  }

  // Field 8: max_uint64
  if (msg.maxUint64 !== undefined && msg.maxUint64 !== null) {
    writer.writeTag(8, WireType.Varint);
    writer.writeVarint64(msg.maxUint64);
  }

  // Field 9: empty_string
  if (msg.emptyString !== undefined && msg.emptyString !== null) {
    writer.writeTag(9, WireType.Bytes);
    writer.writeString(msg.emptyString);
  }

  // Field 10: unicode_string
  if (msg.unicodeString !== undefined && msg.unicodeString !== null) {
    writer.writeTag(10, WireType.Bytes);
    writer.writeString(msg.unicodeString);
  }

  // Field 11: empty_bytes
  if (msg.emptyBytes !== undefined && msg.emptyBytes !== null) {
    writer.writeTag(11, WireType.Bytes);
    writer.writeLengthPrefixedBytes(msg.emptyBytes);
  }
}

/** Decodes a EdgeCases from the reader. */
export function decodeEdgeCases(reader: Reader): EdgeCases {
  const fieldCount = reader.readVarint();
  const result: Partial<EdgeCases> = {};

  for (let i = 0; i < fieldCount; i++) {
    const tag = reader.readTag();
    switch (tag.fieldNumber) {
      case 1:
        result.zeroInt = reader.readSVarint();
        break;
      case 2:
        result.negativeOne = reader.readSVarint();
        break;
      case 3:
        result.maxInt32 = reader.readSVarint();
        break;
      case 4:
        result.minInt32 = reader.readSVarint();
        break;
      case 5:
        result.maxInt64 = reader.readSVarint64();
        break;
      case 6:
        result.minInt64 = reader.readSVarint64();
        break;
      case 7:
        result.maxUint32 = reader.readVarint();
        break;
      case 8:
        result.maxUint64 = reader.readVarint64();
        break;
      case 9:
        result.emptyString = reader.readString();
        break;
      case 10:
        result.unicodeString = reader.readString();
        break;
      case 11:
        result.emptyBytes = reader.readLengthPrefixedBytes();
        break;
      default:
        reader.skipField(tag.wireType);
    }
  }

  return result as EdgeCases;
}

/** Marshals a EdgeCases to bytes. */
export function marshalEdgeCases(msg: EdgeCases): Uint8Array {
  const writer = new Writer();
  encodeEdgeCases(writer, msg);
  return writer.bytes();
}

/** Unmarshals a EdgeCases from bytes. */
export function unmarshalEdgeCases(data: Uint8Array): EdgeCases {
  const reader = new Reader(data);
  return decodeEdgeCases(reader);
}


/** AllFieldNumbers tests various field numbers including large ones. */
export interface AllFieldNumbers {
field1: number;
field15: number;
field16: number;
field127: number;
field128: number;
field1000: number;
}

/** Encodes a AllFieldNumbers to the writer. */
export function encodeAllFieldNumbers(writer: Writer, msg: AllFieldNumbers): void {
  // Count non-empty fields
  let fieldCount = 0;
  if (msg.field1 !== undefined && msg.field1 !== null) fieldCount++;
  if (msg.field15 !== undefined && msg.field15 !== null) fieldCount++;
  if (msg.field16 !== undefined && msg.field16 !== null) fieldCount++;
  if (msg.field127 !== undefined && msg.field127 !== null) fieldCount++;
  if (msg.field128 !== undefined && msg.field128 !== null) fieldCount++;
  if (msg.field1000 !== undefined && msg.field1000 !== null) fieldCount++;
  writer.writeVarint(fieldCount);

  // Field 1: field_1
  if (msg.field1 !== undefined && msg.field1 !== null) {
    writer.writeTag(1, WireType.Varint);
    writer.writeSVarint(msg.field1);
  }

  // Field 15: field_15
  if (msg.field15 !== undefined && msg.field15 !== null) {
    writer.writeTag(15, WireType.Varint);
    writer.writeSVarint(msg.field15);
  }

  // Field 16: field_16
  if (msg.field16 !== undefined && msg.field16 !== null) {
    writer.writeTag(16, WireType.Varint);
    writer.writeSVarint(msg.field16);
  }

  // Field 127: field_127
  if (msg.field127 !== undefined && msg.field127 !== null) {
    writer.writeTag(127, WireType.Varint);
    writer.writeSVarint(msg.field127);
  }

  // Field 128: field_128
  if (msg.field128 !== undefined && msg.field128 !== null) {
    writer.writeTag(128, WireType.Varint);
    writer.writeSVarint(msg.field128);
  }

  // Field 1000: field_1000
  if (msg.field1000 !== undefined && msg.field1000 !== null) {
    writer.writeTag(1000, WireType.Varint);
    writer.writeSVarint(msg.field1000);
  }
}

/** Decodes a AllFieldNumbers from the reader. */
export function decodeAllFieldNumbers(reader: Reader): AllFieldNumbers {
  const fieldCount = reader.readVarint();
  const result: Partial<AllFieldNumbers> = {};

  for (let i = 0; i < fieldCount; i++) {
    const tag = reader.readTag();
    switch (tag.fieldNumber) {
      case 1:
        result.field1 = reader.readSVarint();
        break;
      case 15:
        result.field15 = reader.readSVarint();
        break;
      case 16:
        result.field16 = reader.readSVarint();
        break;
      case 127:
        result.field127 = reader.readSVarint();
        break;
      case 128:
        result.field128 = reader.readSVarint();
        break;
      case 1000:
        result.field1000 = reader.readSVarint();
        break;
      default:
        reader.skipField(tag.wireType);
    }
  }

  return result as AllFieldNumbers;
}

/** Marshals a AllFieldNumbers to bytes. */
export function marshalAllFieldNumbers(msg: AllFieldNumbers): Uint8Array {
  const writer = new Writer();
  encodeAllFieldNumbers(writer, msg);
  return writer.bytes();
}

/** Unmarshals a AllFieldNumbers from bytes. */
export function unmarshalAllFieldNumbers(data: Uint8Array): AllFieldNumbers {
  const reader = new Reader(data);
  return decodeAllFieldNumbers(reader);
}



