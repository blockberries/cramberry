package codegen

import (
	"fmt"
	"io"
	"strings"
	"text/template"

	"github.com/cramberry/cramberry-go/pkg/schema"
)

// TypeScriptGenerator generates TypeScript code from schemas.
type TypeScriptGenerator struct{}

// NewTypeScriptGenerator creates a new TypeScript code generator.
func NewTypeScriptGenerator() *TypeScriptGenerator {
	return &TypeScriptGenerator{}
}

// Language returns the target language.
func (g *TypeScriptGenerator) Language() Language {
	return LanguageTypeScript
}

// FileExtension returns the file extension for generated files.
func (g *TypeScriptGenerator) FileExtension() string {
	return ".ts"
}

// Generate produces TypeScript code from a schema.
func (g *TypeScriptGenerator) Generate(w io.Writer, s *schema.Schema, opts Options) error {
	ctx := &tsContext{
		Schema:  s,
		Options: opts,
	}

	tmpl, err := template.New("typescript").Funcs(ctx.funcMap()).Parse(tsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	return tmpl.Execute(w, ctx)
}

// tsContext holds context for TypeScript code generation.
type tsContext struct {
	Schema  *schema.Schema
	Options Options
}

func (c *tsContext) funcMap() template.FuncMap {
	return template.FuncMap{
		"tsType":           c.tsType,
		"tsFieldType":      c.tsFieldType,
		"tsEnumType":       c.tsEnumType,
		"tsMessageType":    c.tsMessageType,
		"tsInterfaceType":  c.tsInterfaceType,
		"tsFieldName":      c.tsFieldName,
		"tsEnumValueName":  c.tsEnumValueName,
		"comment":          c.tsComment,
		"toCamel":          ToCamelCase,
		"toPascal":         ToPascalCase,
		"toSnake":          ToSnakeCase,
		"generateComments": func() bool { return c.Options.GenerateComments },
	}
}

func (c *tsContext) tsType(t schema.TypeRef) string {
	return c.tsTypeInternal(t, false)
}

func (c *tsContext) tsFieldType(f *schema.Field) string {
	t := c.tsTypeInternal(f.Type, false)

	// Wrap repeated fields in array
	if f.Repeated {
		if _, isArray := f.Type.(*schema.ArrayType); !isArray {
			t = t + "[]"
		}
	}

	return t
}

func (c *tsContext) tsTypeInternal(t schema.TypeRef, inArray bool) string {
	switch typ := t.(type) {
	case *schema.ScalarType:
		return c.tsScalarType(typ.Name)
	case *schema.NamedType:
		name := c.Options.TypePrefix + ToPascalCase(typ.Name) + c.Options.TypeSuffix
		if typ.Package != "" {
			return typ.Package + "." + name
		}
		return name
	case *schema.ArrayType:
		elem := c.tsTypeInternal(typ.Element, true)
		if typ.Size > 0 {
			// Fixed-size arrays become tuples in TypeScript
			return elem + "[]"
		}
		return elem + "[]"
	case *schema.MapType:
		key := c.tsTypeInternal(typ.Key, false)
		val := c.tsTypeInternal(typ.Value, false)
		// TypeScript maps use Record or Map
		if key == "string" {
			return fmt.Sprintf("Record<%s, %s>", key, val)
		}
		return fmt.Sprintf("Map<%s, %s>", key, val)
	case *schema.PointerType:
		elem := c.tsTypeInternal(typ.Element, false)
		return elem + " | null"
	default:
		return "unknown"
	}
}

func (c *tsContext) tsScalarType(name string) string {
	switch name {
	case "bool":
		return "boolean"
	case "int8", "int16", "int32", "int", "uint8", "uint16", "uint32", "uint":
		return "number"
	case "int64", "uint64":
		return "bigint"
	case "float32", "float64":
		return "number"
	case "complex64", "complex128":
		return "{ real: number; imag: number }"
	case "string":
		return "string"
	case "bytes", "byte":
		return "Uint8Array"
	default:
		return name
	}
}

func (c *tsContext) tsEnumType(e *schema.Enum) string {
	return c.Options.TypePrefix + ToPascalCase(e.Name) + c.Options.TypeSuffix
}

func (c *tsContext) tsMessageType(m *schema.Message) string {
	return c.Options.TypePrefix + ToPascalCase(m.Name) + c.Options.TypeSuffix
}

func (c *tsContext) tsInterfaceType(i *schema.Interface) string {
	return c.Options.TypePrefix + ToPascalCase(i.Name) + c.Options.TypeSuffix
}

func (c *tsContext) tsFieldName(f *schema.Field) string {
	return ToCamelCase(f.Name)
}

func (c *tsContext) tsEnumValueName(v *schema.EnumValue) string {
	return ToPascalCase(v.Name)
}

func (c *tsContext) tsComment(text string) string {
	if text == "" {
		return ""
	}
	lines := strings.Split(text, "\n")
	if len(lines) == 1 {
		return "/** " + text + " */"
	}
	result := "/**\n"
	for _, line := range lines {
		result += " * " + line + "\n"
	}
	result += " */"
	return result
}

func init() {
	Register(NewTypeScriptGenerator())
}

const tsTemplate = `// Code generated by cramberry. DO NOT EDIT.
// Source: {{.Schema.Position.Filename}}

{{$ctx := .}}
{{range $enum := .Schema.Enums}}
{{if generateComments}}{{range $enum.Comments}}{{if .IsDoc}}{{comment .Text}}
{{end}}{{end}}{{end -}}
export enum {{tsEnumType $enum}} {
{{- range $enum.Values}}
{{if generateComments}}{{range .Comments}}{{if .IsDoc}}  {{comment .Text}}
{{end}}{{end}}{{end -}}
  {{tsEnumValueName .}} = {{.Number}},
{{- end}}
}

{{end}}
{{range $msg := .Schema.Messages}}
{{if generateComments}}{{range $msg.Comments}}{{if .IsDoc}}{{comment .Text}}
{{end}}{{end}}{{end -}}
export interface {{tsMessageType $msg}} {
{{- range $msg.Fields}}
{{if generateComments}}{{range .Comments}}{{if .IsDoc}}  {{comment .Text}}
{{end}}{{end}}{{end -}}
  {{tsFieldName .}}{{if .Optional}}?{{end}}: {{tsFieldType .}};
{{- end}}
}

{{end}}
{{range $iface := .Schema.Interfaces}}
{{if generateComments}}{{range $iface.Comments}}{{if .IsDoc}}{{comment .Text}}
{{end}}{{end}}{{end -}}
export type {{tsInterfaceType $iface}} = {{range $i, $impl := $iface.Implementations}}{{if $i}} | {{end}}{{$impl.Type.Name}}{{end}};

/** Type ID mapping for {{tsInterfaceType $iface}} */
export const {{tsInterfaceType $iface}}TypeIds = {
{{- range $iface.Implementations}}
  {{.Type.Name}}: {{.TypeID}},
{{- end}}
} as const;

{{end}}
`
